apiVersion: v1
items:
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires that service port names have a prefix from a specified
        list.
      metadata.gatekeeper.sh/title: Allowed Service Port Names
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:08Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: allowedserviceportname
    resourceVersion: "1746760521873871001"
    uid: f2e13c37-9b0b-44e2-b89d-3c48089ba0e1
  spec:
    crd:
      spec:
        names:
          kind: AllowedServicePortName
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              prefixes:
                description: Prefixes of allowed service port names.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package asm.guardrails.allowedserviceportname

        violation[{"msg": msg}] {
          service := input.review.object
          port := service.spec.ports[_]
          prefixes := input.parameters.prefixes

          not is_prefixed(port, prefixes)

          msg := "service port name missing prefix"
        }

        is_prefixed(port, prefixes) {
          prefix := prefixes[_]
          startswith(port.name, prefix)
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: f2e13c37-9b0b-44e2-b89d-3c48089ba0e1
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: f2e13c37-9b0b-44e2-b89d-3c48089ba0e1
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforce the mesh level default deny AuthorizationPolicy. Reference
        to https://istio.io/latest/docs/ops/best-practices/security/#use-default-deny-patterns.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["security.istio.io"],
              "versions": ["v1beta1"],
              "kinds": ["AuthorizationPolicy"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: ASM AuthorizationPolicy Default Deny
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:24Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: asmauthzpolicydefaultdeny
    resourceVersion: "1746760553746735002"
    uid: 02917de3-66e7-4897-9e53-de9314b69d88
  spec:
    crd:
      spec:
        names:
          kind: AsmAuthzPolicyDefaultDeny
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              rootNamespace:
                description: Anthos Service Mesh root namespace, default value is
                  "istio-system" if not specified.
                type: string
              strictnessLevel:
                description: Level of AuthorizationPolicy strictness.
                enum:
                - Low
                - High
                type: string
            type: object
    targets:
    - rego: |
        package asm.security.authorizationpolicy

        ################
        # Mesh Level Default Deny
        ################

        # In the ASM root namespace, there should be a default deny AuthorizationPolicy.

        violation[{"msg": msg}] {
          has_strictness_set_to_high
          is_asm_authz_policy_default_deny(input.review.kind)

          # use input root namespace or default value istio-system
          root_ns := object.get(object.get(input, "parameters", {}), "rootNamespace", "istio-system")
          not namespace_has_default_deny_policy(root_ns)
          msg := sprintf("Root namespace <%v> does not have a default deny AuthorizationPolicy", [root_ns])
        }

        has_strictness_set_to_high {
          input.parameters.strictnessLevel == "High"
        }

        is_asm_authz_policy_default_deny(kind) {
          kind.kind == "AsmAuthzPolicyDefaultDeny"
          kind.group == "constraints.gatekeeper.sh"
        }

        namespace_has_default_deny_policy(ns) {
          ap := data.inventory.namespace[ns][_].AuthorizationPolicy[_]
          is_allow_action(ap)
          not ap.spec.rules
        }

        is_allow_action(ap) {
          ap.spec.action == "ALLOW"
        }

        is_allow_action(ap) {
          not ap.spec.action
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 02917de3-66e7-4897-9e53-de9314b69d88
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 02917de3-66e7-4897-9e53-de9314b69d88
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires that principals and namespaces in Istio `AuthorizationPolicy` rules not have a prefix from a specified list.
        https://istio.io/latest/docs/reference/config/security/authorization-policy/
      metadata.gatekeeper.sh/title: ASM AuthorizationPolicy Disallowed Prefixes
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:07Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmauthzpolicydisallowedprefix
    resourceVersion: "1746760515485903019"
    uid: 71e4dbc9-6d6e-41db-b8de-2fdd3378747b
  spec:
    crd:
      spec:
        names:
          kind: AsmAuthzPolicyDisallowedPrefix
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              disallowedNamespacePrefixes:
                description: Disallowed prefixes for namespaces.
                items:
                  type: string
                type: array
              disallowedPrincipalPrefixes:
                description: Disallowed prefixes for principals.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package asm.security.authorizationpolicy

        spec := input.review.object.spec

        is_authzpolicy(kind) {
          kind.kind == "AuthorizationPolicy"
          kind.group == "security.istio.io"
        }

        ################
        # From Source Principals
        ################

        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)
          principal := spec.rules[_].from[_].source.principals[_]
          parts := split(principal, "/")
          badprefix := input.parameters.disallowedPrincipalPrefixes[_]

          # check the final component of source.principals, the service account name
          startswith(parts[count(parts) - 1], badprefix)
          msg := sprintf("source.principals '%v' cannot begin with '%v'", [principal, badprefix])
        }

        ################
        # From Source Namespaces
        ################

        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)
          namespace := spec.rules[_].from[_].source.namespaces[_]
          badprefix := input.parameters.disallowedNamespacePrefixes[_]
          startswith(namespace, badprefix)
          msg := sprintf("source.namespaces '%v' cannot begin with '%v'", [namespace, badprefix])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 71e4dbc9-6d6e-41db-b8de-2fdd3378747b
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 71e4dbc9-6d6e-41db-b8de-2fdd3378747b
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires that Istio AuthorizationPolicy "from" field, when defined, has source principles, which must be set to something other than "*".
        https://istio.io/latest/docs/reference/config/security/authorization-policy/
      metadata.gatekeeper.sh/title: ASM AuthorizationPolicy Enforcement Principals
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmauthzpolicyenforcesourceprincipals
    resourceVersion: "1746760520143743014"
    uid: a00a58f8-b07a-4d5d-901c-18081c32a438
  spec:
    crd:
      spec:
        names:
          kind: AsmAuthzPolicyEnforceSourcePrincipals
        validation:
          legacySchema: false
    targets:
    - rego: |
        package asm.security.authorizationpolicy

        spec := input.review.object.spec

        is_authzpolicy(kind) {
          kind.kind == "AuthorizationPolicy"
          kind.group == "security.istio.io"
        }

        ################
        # From Source Principals
        ################

        # spec.rules[].from[].source.principals does not exist
        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)
          from := spec.rules[_].from
          not contains_principals(from)
          msg := "source.principals does not exist"
        }

        contains_principals(from) {
          from[_].source.principals
        }

        # spec.rules[].from[].source.principals[] does not contain '*'
        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)
          principal := spec.rules[_].from[_].source.principals[_]
          principal == "*"
          msg := "source.principals[] cannot be '*'"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: a00a58f8-b07a-4d5d-901c-18081c32a438
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: a00a58f8-b07a-4d5d-901c-18081c32a438
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforce the AuthorizationPolicy normalization. Reference to https://istio.io/latest/docs/reference/config/security/normalization/.
      metadata.gatekeeper.sh/title: ASM AuthorizationPolicy Normalization
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:11Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmauthzpolicynormalization
    resourceVersion: "1746760538051311011"
    uid: 119f3362-cde8-4806-b570-d1a8dcad534e
  spec:
    crd:
      spec:
        names:
          kind: AsmAuthzPolicyNormalization
        validation:
          legacySchema: false
    targets:
    - rego: |
        package asm.security.authorizationpolicy

        spec := input.review.object.spec

        is_authzpolicy(kind) {
          kind.kind == "AuthorizationPolicy"
          kind.group == "security.istio.io"
        }

        ################
        # To Operation Method
        ################

        # Methods and notMethods should only contain uppercase letters.

        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)
          has_invalid_method_or_notMethods
          msg := "in rules-to-operation, methods or notMethods must be uppercase"
        }

        has_invalid_method_or_notMethods {
          has_lower_case_method(spec.rules[_].to[_].operation.methods)
        }

        has_invalid_method_or_notMethods {
          has_lower_case_method(spec.rules[_].to[_].operation.notMethods)
        }

        has_lower_case_method(methods) {
          has_lower_case_letter(methods[_])
        }

        # has_lower_case_letter checks whether a string has any lower case letters.
        has_lower_case_letter(s) {
          not s == upper(s)
        }

        ################
        # When Request Header
        ################

        # request.headers[<header-name>] must not contain white space.

        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)
          has_white_space_in_request_header(spec.rules[_].when[_].key)
          msg := "rules-when-request.header must not contain white spaces"
        }

        has_white_space_in_request_header(key) {
          is_authzpolicy(input.review.kind)
          startswith(key, "request.headers")
          not regex.match(`^request\.headers\[\S+\]$`, key)
        }

        ################
        # To Operation Paths
        ################

        # Paths should be always normalized, and suggest users to set mesh level normalization if not.

        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)
          has_unnormalized_path_or_notPath
          msg := `in rule-to-operation, paths or notPaths contain at least one unnormalized value: [\, //, /./, /../], please set mesh config pathNormalization value for normalization and update path to normalized value.`
        }

        has_unnormalized_path_or_notPath {
          has_unnormalized_path(spec.rules[_].to[_].operation.paths[_])
        }

        has_unnormalized_path_or_notPath {
          has_unnormalized_path(spec.rules[_].to[_].operation.notPaths[_])
        }

        has_unnormalized_path(path) {
          contains(path, `\`)
        }

        has_unnormalized_path(path) {
          contains(path, `//`)
        }

        has_unnormalized_path(path) {
          contains(path, `/./`)
        }

        has_unnormalized_path(path) {
          contains(path, `/../`)
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 119f3362-cde8-4806-b570-d1a8dcad534e
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 119f3362-cde8-4806-b570-d1a8dcad534e
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforce the AuthorizationPolicy safe patterns. Reference to https://istio.io/latest/docs/ops/best-practices/security/#safer-authorization-policy-patterns.
      metadata.gatekeeper.sh/title: ASM AuthorizationPolicy Safe Patterns
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:08Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmauthzpolicysafepattern
    resourceVersion: "1746760524738831001"
    uid: 4b3f29f8-5354-41a6-af86-b69875b91ee8
  spec:
    crd:
      spec:
        names:
          kind: AsmAuthzPolicySafePattern
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              strictnessLevel:
                description: Level of AuthorizationPolicy strictness.
                enum:
                - Low
                - High
                type: string
            type: object
    targets:
    - rego: |
        package asm.security.authorizationpolicy

        spec := input.review.object.spec

        is_authzpolicy(kind) {
          kind.kind == "AuthorizationPolicy"
          kind.group == "security.istio.io"
        }

        has_strictness_set_to_high {
          input.parameters.strictnessLevel == "High"
        }

        ################
        # To Operation Hosts
        ################

        # hosts and notHosts field should only be used in ingress gateways rather than sidecar proxies.
        # Current logic is check whether the label "istio" or "asm" contains keyword "ingressgateway".
        # This is valid when following two conditions are true.
        # 1. ASM installation instruction will not let user modify ingressgateway label, label istio or
        #    asm still contains keyword ingressgateway.
        # 2. Combined with IngressgatewayLabel constraint which enforce "istio: ingressgateway" or
        #    "asm: ingressgateway" label can only be applied on actual ingress gateway pod.
        # Current ASM ingressgateway labels: "app: istio-ingressgateway, istio: ingressgateway", or
        # "app: asm-ingressgateway, asm: ingressgateway"

        violation[{"msg": msg}] {
          is_authzpolicy(input.review.kind)

          # check if there are hosts or notHosts fields
          has_hosts_or_notHosts_fields

          # check if the selector not contains a key istio with ingressgateway keyword
          not has_ingressgateway_label
          msg := "in rules-to-operation, hosts or notHosts should only be used in ingress gateway"
        }

        has_hosts_or_notHosts_fields {
          spec.rules[_].to[_].operation.hosts
        }

        has_hosts_or_notHosts_fields {
          spec.rules[_].to[_].operation.notHosts
        }

        has_ingressgateway_label {
          # check if there is a label value contains ingressgateway keyword
          contains(spec.selector.matchLabels.istio, "ingressgateway")
        }

        has_ingressgateway_label {
          # check if there is a label value contains ingressgateway keyword
          contains(spec.selector.matchLabels.asm, "ingressgateway")
        }

        # hosts and notHosts field should contain <host-name> and <host-name>:* value pairs
        violation[{"msg": msg}] {
          has_strictness_set_to_high
          is_authzpolicy(input.review.kind)

          # check if there are invalid hosts or notHosts fields
          contains_invalid_hosts_or_notHosts_values
          msg := "in rules-to-operation, hosts or notHosts should contain <host-name> and <host-name>:* value pairs"
        }

        contains_invalid_hosts_or_notHosts_values {
          hosts := spec.rules[_].to[_].operation.hosts
          not valid_hosts(hosts)
        }

        contains_invalid_hosts_or_notHosts_values {
          not_hosts := spec.rules[_].to[_].operation.notHosts
          not valid_hosts(not_hosts)
        }

        valid_hosts(hosts) {
          some i
          hostnames := {hostname | not contains(hosts[i], ":"); hostname := hosts[i]}
          hostname_ports := {hostname_port | endswith(hosts[i], ":*"); hostname_port := hosts[i]}

          # trim the port from hostname_ports
          trimed_hostname_ports := {hp | hostname_ports[i]; hp := trim_suffix(hostname_ports[i], ":*")}

          # check hostname and hostname:* with same number
          count(hostnames) == count(hostname_ports)

          # check there are no extra host
          count(hosts) == count(hostnames) + count(hostname_ports)

          # check hostname are the matched ones for hostname:*
          count(hostnames - trimed_hostname_ports) == 0
        }

        ################
        # Authorization Policy Patterns
        ################

        # For safer security, AuthorizaionPolicy should use ALLOW-with-positive-matching
        # or DENY-with-negative-match. This is enabled if the strictnessLevel is H (high).
        # Ref: https://istio.io/latest/docs/ops/best-practices/security/#use-allow-with-positive-matching-and-deny-with-negative-match-patterns

        # ALLOW-with-positive-matching
        violation[{"msg": msg}] {
          has_strictness_set_to_high
          is_authzpolicy(input.review.kind)

          # check if action is ALLOW
          spec.action == "ALLOW"

          # check if rules contains negative matching
          has_negative_matching(spec.rules)
          msg := "ALLOW action should only use positive matching, e.g. hosts, ports, methods, paths, values"
        }

        has_negative_matching(rules) {
          rules[_].to[_].operation.notHosts
        }

        has_negative_matching(rules) {
          rules[_].to[_].operation.notPorts
        }

        has_negative_matching(rules) {
          rules[_].to[_].operation.notMethods
        }

        has_negative_matching(rules) {
          rules[_].to[_].operation.notPaths
        }

        has_negative_matching(rules) {
          rules[_].when[_].notValues
        }

        # DENY-with-negative-match
        violation[{"msg": msg}] {
          has_strictness_set_to_high
          is_authzpolicy(input.review.kind)

          # check if action is ALLOW
          spec.action == "DENY"

          # check if rules contains positive matching
          has_positive_matching(spec.rules)
          msg := "DENY action should only use negative matching, e.g. notHosts, notPorts, notMethods, notPaths, notValues"
        }

        has_positive_matching(rules) {
          rules[_].to[_].operation.hosts
        }

        has_positive_matching(rules) {
          rules[_].to[_].operation.ports
        }

        has_positive_matching(rules) {
          rules[_].to[_].operation.methods
        }

        has_positive_matching(rules) {
          rules[_].to[_].operation.paths
        }

        has_positive_matching(rules) {
          rules[_].when[_].values
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 4b3f29f8-5354-41a6-af86-b69875b91ee8
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 4b3f29f8-5354-41a6-af86-b69875b91ee8
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforce the istio ingressgateway label usage only on ingressgateway
        pods.
      metadata.gatekeeper.sh/title: ASM Ingress Gateway Label
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:11Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmingressgatewaylabel
    resourceVersion: "1746760540474639008"
    uid: e3fb13d8-f9fe-4885-9d27-ba38aca1457f
  spec:
    crd:
      spec:
        names:
          kind: AsmIngressgatewayLabel
        validation:
          legacySchema: false
    targets:
    - rego: |
        package asm.security.workloadpolicy

        resource := input.review.object

        spec := resource.spec

        ################
        # Ingressgateway label
        ################

        # Label `istio: ingressgateway` should only be used on istio ingressgateway pod,
        # which container image starts with `gcr.io/gke-release/asm/proxyv2:`.

        ingress_labels := [{"key": "istio", "value": "ingressgateway"}, {"key": "asm", "value": "ingressgateway"}]

        ingress_image_prefix := "gcr.io/gke-release/asm/proxyv2:"

        violation[{"msg": msg}] {
          is_pod(input.review.kind)
          contains_ingress_label
          not is_pod_istio_ingressgateway
          msg := "The label `istio:ingressgateway` and `asm:ingressgateway` can only be used on asm ingressgateway pods."
        }

        contains_ingress_label {
          some i
          contains(resource.metadata.labels[ingress_labels[i].key], ingress_labels[i].value)
        }

        is_pod_istio_ingressgateway {
          count(spec.containers) == 1
          startswith(spec.containers[_].image, ingress_image_prefix)
        }

        is_pod(kind) {
          kind.kind == "Pod"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: e3fb13d8-f9fe-4885-9d27-ba38aca1457f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: e3fb13d8-f9fe-4885-9d27-ba38aca1457f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforce the mesh level strict mtls PeerAuthentication. Reference
        to https://istio.io/latest/docs/ops/best-practices/security/#mutual-tls.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["security.istio.io"],
              "versions": ["v1beta1"],
              "kinds": ["PeerAuthentication"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: ASM Peer Authentication Mesh Strict mTLS
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:15Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: asmpeerauthnmeshstrictmtls
    resourceVersion: "1746760549842127021"
    uid: 26a4a4d0-f7fe-44b7-95cf-06b3fe017f9f
  spec:
    crd:
      spec:
        names:
          kind: AsmPeerAuthnMeshStrictMtls
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              rootNamespace:
                description: Anthos Service Mesh root namespace, default value is
                  "istio-system" if not specified.
                type: string
              strictnessLevel:
                description: Level of PeerAuthentication strictness.
                enum:
                - Low
                - High
                type: string
            type: object
    targets:
    - rego: |
        package asm.security.peerauthentication

        ################
        # Mesh Level Strict mTLS
        ################

        # In the ASM root namespace, there should be a strict mTLS PeerAuthentication.

        violation[{"msg": msg}] {
          has_strictness_set_to_high
          is_asm_peer_authn_mesh_strict_mtls(input.review.kind)

          # use input root namespace or default value istio-system
          root_ns := object.get(object.get(input, "parameters", {}), "rootNamespace", "istio-system")
          not namespace_has_default_strict_mtls_pa(root_ns)
          msg := sprintf("Root namespace <%v> does not have a strict mTLS PeerAuthentication", [root_ns])
        }

        namespace_has_default_strict_mtls_pa(ns) {
          pa := data.inventory.namespace[ns][_].PeerAuthentication[_]
          pa.spec.mtls.mode == "STRICT"
        }

        is_asm_peer_authn_mesh_strict_mtls(kind) {
          kind.kind == "AsmPeerAuthnMeshStrictMtls"
          kind.group == "constraints.gatekeeper.sh"
        }

        has_strictness_set_to_high {
          input.parameters.strictnessLevel == "High"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 26a4a4d0-f7fe-44b7-95cf-06b3fe017f9f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 26a4a4d0-f7fe-44b7-95cf-06b3fe017f9f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforce all PeerAuthentications cannot overwrite strict mtls. Reference
        to https://istio.io/latest/docs/ops/best-practices/security/#mutual-tls.
      metadata.gatekeeper.sh/title: ASM Peer Authentication Strict mTLS
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:08Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmpeerauthnstrictmtls
    resourceVersion: "1746760515400703008"
    uid: 3dfdd8f4-a6f7-4bd8-9594-45cce3596cc6
  spec:
    crd:
      spec:
        names:
          kind: AsmPeerAuthnStrictMtls
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              strictnessLevel:
                description: Level of PeerAuthentication strictness.
                enum:
                - Low
                - High
                type: string
            type: object
    targets:
    - rego: |
        package asm.security.peerauthentication

        spec := input.review.object.spec

        valid_modes := {"UNSET", "STRICT"}

        ################
        # Strict mTLS
        ################

        # mTLS mode can only be set to either UNSET or STRICT for all PeerAuthentications in the mesh.

        violation[{"msg": msg}] {
          has_strictness_set_to_high
          is_peerauthentication(input.review.kind)
          count({spec.mtls.mode} - valid_modes) > 0
          msg := "PeerAuthentication mtls mode can only be set to UNSET or STRICT"
        }

        # port level mtls
        violation[{"msg": msg}] {
          some port
          input.parameters.strictnessLevel == "High"
          is_peerauthentication(input.review.kind)
          count({spec.portLevelMtls[port].mode} - valid_modes) > 0
          msg := sprintf("PeerAuthentication port <%v> has invalid mtls mode <%v>, it can only be set to UNSET or STRICT", [port, spec.portLevelMtls[port].mode])
        }

        is_peerauthentication(kind) {
          kind.kind == "PeerAuthentication"
          kind.group == "security.istio.io"
        }

        has_strictness_set_to_high {
          input.parameters.strictnessLevel == "High"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 3dfdd8f4-a6f7-4bd8-9594-45cce3596cc6
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 3dfdd8f4-a6f7-4bd8-9594-45cce3596cc6
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: In RequestAuthentication, enforce the `jwtRules.outPayloadToHeader`
        field to not contain well known HTTP request headers or custom prohibited
        headers. Reference to https://istio.io/latest/docs/reference/config/security/jwt/#JWTRule.
      metadata.gatekeeper.sh/title: ASM RequestAuthentication Prohibited Output Headers
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:25Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmrequestauthnprohibitedoutputheaders
    resourceVersion: "1746760554162479021"
    uid: 254bde76-a09a-4b62-b81a-23fad532c51f
  spec:
    crd:
      spec:
        names:
          kind: AsmRequestAuthnProhibitedOutputHeaders
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              prohibitedHeaders:
                description: User predefined prohibited headers.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package asm.security.requestauthentication

        resource := input.review.object

        spec := resource.spec

        controls_headers := {"Cache-Control", "Expect", "Host", "Max-Forwards", "Pragma", "Range", "TE"}

        conditional_headers := {"If-Match", "If-None-Match", "If-Modified-Since", "If-Unmodified-Since", "If-Range"}

        content_negotiation_headers := {"Accept", "Accept-Charset", "Accept-Encoding", "Accept-Language"}

        authentication_credentials_headers := {"Authorization", "Proxy-Authorization"}

        request_context_headers := {"From", "Referer", "User-Agent"}

        well_known_headers := (((controls_headers | conditional_headers) | content_negotiation_headers) | authentication_credentials_headers) | request_context_headers

        ################
        # jwtRules outputPayloadToHeader
        ################

        # outputPayloadToHeader must not contain well known headers
        violation[{"msg": msg}] {
          is_requestauthn(input.review.kind)
          header := spec.jwtRules[_].outputPayloadToHeader
          well_known_headers[header]
          msg := sprintf("RequestAuthentication jwtRules outputPayloadToHeader contains well known header: %v", [header])
        }

        # outputPalyloadToHeader must not contain predefined prohibited headers
        violation[{"msg": msg}] {
          is_requestauthn(input.review.kind)
          input_prohibited_headers := {x | x = input.parameters.prohibitedHeaders[_]}
          header := spec.jwtRules[_].outputPayloadToHeader
          input_prohibited_headers[header]
          msg := sprintf("RequestAuthentication jwtRules outputPayloadToHeader contains predefined prohibited header: %v", [header])
        }

        is_requestauthn(kind) {
          kind.kind == "RequestAuthentication"
          kind.group == "security.istio.io"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 254bde76-a09a-4b62-b81a-23fad532c51f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 254bde76-a09a-4b62-b81a-23fad532c51f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforce the istio proxy sidecar always been injected to workload
        pods.
      metadata.gatekeeper.sh/title: ASM Sidecar Injection
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:10Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: asmsidecarinjection
    resourceVersion: "1746760529485855014"
    uid: e70ec7f2-09e5-46cc-9d4e-79946eed05fe
  spec:
    crd:
      spec:
        names:
          kind: AsmSidecarInjection
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              strictnessLevel:
                description: Level of sidecar injection strictness.
                enum:
                - Low
                - High
                type: string
            type: object
    targets:
    - rego: |
        package asm.security.workloadpolicy

        resource := input.review.object

        spec := resource.spec

        ################
        # Sidecar injection annotation
        ################

        # Annotation `sidecar.istio.io/inject: false` should not be applied on workload pods which will bypass istio proxy.

        forbidden_injection_annotation := {"key": "sidecar.istio.io/inject", "value": "false"}

        violation[{"msg": msg}] {
          has_strictness_set_to_high
          is_pod(input.review.kind)
          contains(resource.metadata.annotations[forbidden_injection_annotation.key], forbidden_injection_annotation.value)
          msg := sprintf("The annotation %v: %v should not be applied on workload pods", [forbidden_injection_annotation.key, forbidden_injection_annotation.value])
        }

        has_strictness_set_to_high {
          input.parameters.strictnessLevel == "High"
        }

        is_pod(kind) {
          kind.kind == "Pod"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: e70ec7f2-09e5-46cc-9d4e-79946eed05fe
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: e70ec7f2-09e5-46cc-9d4e-79946eed05fe
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Prohibits disabling TLS for all hosts and host subsets in Istio
        DestinationRules.
      metadata.gatekeeper.sh/title: Destination Rule TLS Enabled
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:19Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: destinationruletlsenabled
    resourceVersion: "1746760551862591005"
    uid: a39a8693-b7a4-48f9-ad09-4e6f97ad0ac9
  spec:
    crd:
      spec:
        names:
          kind: DestinationRuleTLSEnabled
        validation:
          legacySchema: false
    targets:
    - rego: |
        package asm.guardrails.destinationruletlsenabled

        # spec.trafficPolicy.tls.mode == DISABLE
        violation[{"msg": msg}] {
          d := input.review.object

          startswith(d.apiVersion, "networking.istio.io/")
          d.kind == "DestinationRule"

          tpl := d.spec.trafficPolicy[_]

          tpl == {"mode": "DISABLE"}

          msg := sprintf("spec.trafficPolicy.tls.mode == DISABLE for host(s): %v", [d.spec.host])
        }

        # spec.subsets[].trafficPolicy.tls.mode == DISABLE
        violation[{"msg": msg}] {
          d := input.review.object

          startswith(d.apiVersion, "networking.istio.io/")
          d.kind == "DestinationRule"

          subset := d.spec.subsets[_]
          subset.trafficPolicy == {"tls": {"mode": "DISABLE"}}

          msg := sprintf("subsets[].trafficPolicy.tls.mode == DISABLE for host-subset: %v-%v", [d.spec.host, subset.name])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: a39a8693-b7a4-48f9-ad09-4e6f97ad0ac9
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: a39a8693-b7a4-48f9-ad09-4e6f97ad0ac9
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires that principals and namespaces in Istio `AuthorizationPolicy` rules not have a prefix from a specified list.
        https://istio.io/latest/docs/reference/config/security/authorization-policy/
      metadata.gatekeeper.sh/title: Disallow Istio AuthorizationPolicy Prefixes
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:06Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: disallowedauthzprefix
    resourceVersion: "1746760509802479002"
    uid: 3204f456-720b-427a-bcf6-820190b936e0
  spec:
    crd:
      spec:
        names:
          kind: DisallowedAuthzPrefix
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              disallowedprefixes:
                description: Disallowed prefixes of principals and namespaces.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package asm.guardrails.disallowedauthzprefix

        violation[{"msg": msg}] {
          p := input.review.object

          startswith(p.apiVersion, "security.istio.io/")
          p.kind == "AuthorizationPolicy"

          rule := p.spec.rules[_]
          from := rule.from[_]

          principal := from.source.principals[_]
          parts := split(principal, "/")

          badprefix := input.parameters.disallowedprefixes[_]

          # check the final component of source.principals, the service account name
          startswith(parts[count(parts) - 1], badprefix)

          msg := sprintf("source.principals '%v' cannot begin with '%v'", [principal, badprefix])
        }

        violation[{"msg": msg}] {
          p := input.review.object

          startswith(p.apiVersion, "security.istio.io/")
          p.kind == "AuthorizationPolicy"

          rule := p.spec.rules[_]
          from := rule.from[_]

          namespace := from.source.namespaces[_]

          badprefix := input.parameters.disallowedprefixes[_]
          startswith(namespace, badprefix)

          msg := sprintf("source.namespaces '%v' cannot begin with '%v'", [namespace, badprefix])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 3204f456-720b-427a-bcf6-820190b936e0
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 3204f456-720b-427a-bcf6-820190b936e0
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts the permitted `locations` for StorageBucket Config Connector
        resources to the list of locations provided in the constraint. Bucket names
        in the `exemptions` list are exempt.
      metadata.gatekeeper.sh/title: GCP Storage Location Constraint
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:16Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: gcpstoragelocationconstraintv1
    resourceVersion: "1746760550783119004"
    uid: 8b82adab-1d29-4eae-a8c9-57640b867a79
  spec:
    crd:
      spec:
        names:
          kind: GCPStorageLocationConstraintV1
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptions:
                description: A list of bucket names that are exempt from this constraint.
                items:
                  type: string
                type: array
              locations:
                description: A list of locations that a bucket is permitted to have.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package gcpstoragelocationconstraintv1

        import future.keywords.in

        allowedLocation(reviewLocation) {
          locations := input.parameters.locations[_]
          contains(lower(reviewLocation), lower(locations))
        }

        exempt(reviewName) {
          reviewName in input.parameters.exemptions
        }

        violation[{"msg": msg}] {
          bucketName := input.review.object.metadata.name
          not input.review.object.spec.location
          msg := sprintf("Cloud Storage bucket <%v> must include a location", [bucketName])
        }

        violation[{"msg": msg}] {
          bucketName := input.review.object.metadata.name
          bucketLocation := input.review.object.spec.location
          not allowedLocation(bucketLocation)
          not exempt(bucketName)
          msg := sprintf("Cloud Storage bucket <%v> uses a disallowed location <%v>, allowed locations are %v", [bucketName, bucketLocation, input.parameters.locations])
        }

        violation[{"msg": msg}] {
          not input.parameters.locations
          bucketName := input.review.object.metadata.name
          msg := sprintf("No permitted locations for Cloud Storage bucket <%v>", [bucketName])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8b82adab-1d29-4eae-a8c9-57640b867a79
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8b82adab-1d29-4eae-a8c9-57640b867a79
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires Pods and Pod Templates with `nodeSelector` or `nodeAfffinty`
        of `gke-spot` to have a `terminationGracePeriodSeconds` of 15s or less.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": [""],
              "versions": ["v1"],
              "kinds": ["Node"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Restricts terminationGracePeriodSeconds for GKE
        Spot VMs
      metadata.gatekeeper.sh/version: 1.1.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:15Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: gkespotvmterminationgrace
    resourceVersion: "1746760549290063017"
    uid: 5763bf60-0c52-4300-ab2a-6cf13f88c887
  spec:
    crd:
      spec:
        names:
          kind: GkeSpotVMTerminationGrace
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              includePodOnSpotNodes:
                default: false
                description: Require `terminationGracePeriodSeconds` of 15s or less
                  for all `Pod` on a `gke-spot` Node.
                type: boolean
            type: object
    targets:
    - rego: |
        package gkespotvmterminationgrace

        spot_key := "cloud.google.com/gke-spot"

        violation[{"msg": msg}] {
          has_selector_or_affinity(input.review.object.spec, spot_key)
          termGrace := object.get(input.review.object.spec, "terminationGracePeriodSeconds", null)
          not is_number_less_equal_15(termGrace)
          msg := sprintf("%v with gke-spot nodeSelector or nodeAffinity must have terminationGracePeriodSeconds <= 15s, found: %v", [input.review.kind.kind, termGrace])
        }

        violation[{"msg": msg}] {
          some node
          input.parameters.includePodOnSpotNodes == true
          data.inventory.cluster.v1.Node[node].metadata.labels[spot_key] == "true"
          termGrace := object.get(input.review.object.spec, "terminationGracePeriodSeconds", null)
          not is_number_less_equal_15(termGrace)
          msg := sprintf("%v on gke-spot Node <%v> must have terminationGracePeriodSeconds <= 15s, found: %v", [input.review.kind.kind, input.review.object.spec.Nodename, termGrace])
        }

        has_selector_or_affinity(review, spot_key) {
          review.nodeSelector[spot_key] == "true"
        }

        has_selector_or_affinity(review, spot_key) {
          review.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[_].matchExpressions[_].key == spot_key
        }

        is_number_less_equal_15(value) {
          is_number(value)
          value <= 15
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 5763bf60-0c52-4300-ab2a-6cf13f88c887
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 5763bf60-0c52-4300-ab2a-6cf13f88c887
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires container images to begin with a string from the specified
        list.
      metadata.gatekeeper.sh/title: Allowed Repositories
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sallowedrepos
    resourceVersion: "1746760521231711016"
    uid: e1076e7a-5f6e-4ea1-adcb-b2a6118b958a
  spec:
    crd:
      spec:
        names:
          kind: K8sAllowedRepos
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              repos:
                description: The list of prefixes a container image is allowed to
                  have.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8sallowedrepos

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not strings.any_prefix_match(container.image, input.parameters.repos)
          msg := sprintf("container <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          not strings.any_prefix_match(container.image, input.parameters.repos)
          msg := sprintf("initContainer <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.ephemeralContainers[_]
          not strings.any_prefix_match(container.image, input.parameters.repos)
          msg := sprintf("ephemeralContainer <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: e1076e7a-5f6e-4ea1-adcb-b2a6118b958a
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: e1076e7a-5f6e-4ea1-adcb-b2a6118b958a
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows the use of 'system:masters' group. Has no effect during
        audit.
      metadata.gatekeeper.sh/title: Disallow the use of 'system:masters' group
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:23Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8savoiduseofsystemmastersgroup
    resourceVersion: "1746760553350111010"
    uid: b866f97e-54bb-4c8f-8dbb-3ed98661fb3e
  spec:
    crd:
      spec:
        names:
          kind: K8sAvoidUseOfSystemMastersGroup
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowlistedUsernames:
                description: allowlistedUsernames is the list of usernames that are
                  allowed to use system:masters group.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8savoiduseofsystemmastersgroup

        import future.keywords.in

        violation[{"msg": msg}] {
          user_is_assigned_to_system_masters_group
          not user_is_allowed_to_use_system_masters_group
          not is_break_glass_procedure
          msg := "The use of 'system:masters' group is disallowed."
        }

        user_is_assigned_to_system_masters_group {
          groups := object.get(input.review.userInfo, "groups", [])
          "system:masters" in groups
        }

        user_is_allowed_to_use_system_masters_group {
          username := object.get(input.review.userInfo, "username", "")
          username in input.parameters.allowlistedUsernames
        }

        # In case of the lockout, the break glass procedure allows to delete current constraint
        is_break_glass_procedure {
          input.review.operation == "DELETE"
          input.review.object.kind == "K8sAvoidUseOfSystemMastersGroup"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b866f97e-54bb-4c8f-8dbb-3ed98661fb3e
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b866f97e-54bb-4c8f-8dbb-3ed98661fb3e
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows the creation of Ingress objects (`Ingress`, `Gateway`,
        and `Service` types of `NodePort` and `LoadBalancer`).
      metadata.gatekeeper.sh/title: Block all Ingress
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:22Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblockallingress
    resourceVersion: "1746760553145935006"
    uid: ca28de25-0a69-4668-9a8c-80d752f97251
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockAllIngress
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowList:
                description: A list of regular expressions for the Ingress object
                  names that are exempt from the constraint.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8sblockallingress

        import future.keywords.in

        violation[{"msg": msg}] {
          ingress_object(input)
          not in_list(input.parameters.allowList, input.review.object.metadata.name)
          msg := sprintf("<%v> ingress object is invalid and is not present in the constraint allowList.", [input.review.object.metadata.name])
        }

        in_list(list, elem) {
          allowedRegex := list[_]
          regex.match(allowedRegex, elem)
        }

        ingress_object(val) {
          val.review.kind.kind == "Service"
          val.review.object.spec.type in {"NodePort", "LoadBalancer"}
        }

        ingress_object(val) {
          val.review.kind.kind == "Gateway"
        }

        ingress_object(val) {
          val.review.kind.kind == "Ingress"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: ca28de25-0a69-4668-9a8c-80d752f97251
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: ca28de25-0a69-4668-9a8c-80d752f97251
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows the creation of resources using a default service account.
        Has no effect during audit.
      metadata.gatekeeper.sh/title: Block Creation with Default Service Account
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:17Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblockcreationwithdefaultserviceaccount
    resourceVersion: "1746760551083551008"
    uid: dc4c4fc8-b3c6-43fc-a7fa-5075324b90b8
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockCreationWithDefaultServiceAccount
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8sblockcreationwithdefaultserviceaccount

        violation[{"msg": msg}] {
          input.review.operation == "CREATE"
          username := object.get(input.review.userInfo, "username", "")
          startswith(username, "system:serviceaccount:")
          endswith(username, ":default")
          msg := "Creation is blocked with default service account."
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: dc4c4fc8-b3c6-43fc-a7fa-5075324b90b8
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: dc4c4fc8-b3c6-43fc-a7fa-5075324b90b8
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Many Kubernetes installations by default have a system:aggregate-to-edit ClusterRole which does not properly restrict access to editing Endpoints. This ConstraintTemplate forbids the system:aggregate-to-edit ClusterRole from granting permission to create/patch/update Endpoints.
        ClusterRole/system:aggregate-to-edit should not allow Endpoint edit permissions due to CVE-2021-25740, Endpoint & EndpointSlice permissions allow cross-Namespace forwarding, https://github.com/kubernetes/kubernetes/issues/103675
      metadata.gatekeeper.sh/title: Block Endpoint Edit Default Role
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:16Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblockendpointeditdefaultrole
    resourceVersion: "1746760550603071012"
    uid: 5961fea3-f11c-4e78-9a60-98e2b59ec180
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockEndpointEditDefaultRole
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8sblockendpointeditdefaultrole

        violation[{"msg": msg}] {
            input.review.object.metadata.name == "system:aggregate-to-edit"
            endpointRule(input.review.object.rules[_])
            msg := "ClusterRole system:aggregate-to-edit should not allow endpoint edit permissions. For k8s version < 1.22, the Cluster Role should be annotated with rbac.authorization.kubernetes.io/autoupdate=false to prevent autoreconciliation back to default permissions for this role."
        }

        endpointRule(rule) {
            "endpoints" == rule.resources[_]
            hasEditVerb(rule.verbs)
        }

        hasEditVerb(verbs) {
            "create" == verbs[_]
        }

        hasEditVerb(verbs) {
            "patch" == verbs[_]
        }

        hasEditVerb(verbs) {
            "update" == verbs[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 5961fea3-f11c-4e78-9a60-98e2b59ec180
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 5961fea3-f11c-4e78-9a60-98e2b59ec180
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Disallows all Services with type LoadBalancer.
        https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer
      metadata.gatekeeper.sh/title: Block Services with type LoadBalancer
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:18Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblockloadbalancer
    resourceVersion: "1746760551548127008"
    uid: 8aed8db1-64e7-4dd1-9cfe-712a46028f56
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockLoadBalancer
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8sblockloadbalancer

        violation[{"msg": msg}] {
          input.review.kind.kind == "Service"
          input.review.object.spec.type == "LoadBalancer"
          msg := "User is not allowed to create service of type LoadBalancer"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8aed8db1-64e7-4dd1-9cfe-712a46028f56
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8aed8db1-64e7-4dd1-9cfe-712a46028f56
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Disallows all Services with type NodePort.
        https://kubernetes.io/docs/concepts/services-networking/service/#nodeport
      metadata.gatekeeper.sh/title: Block NodePort
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:21Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblocknodeport
    resourceVersion: "1746760552962383012"
    uid: 3acb71f3-3813-4bcd-8bdc-c831e53ca18c
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockNodePort
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8sblocknodeport

        violation[{"msg": msg}] {
          input.review.kind.kind == "Service"
          input.review.object.spec.type == "NodePort"
          msg := "User is not allowed to create service of type NodePort"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 3acb71f3-3813-4bcd-8bdc-c831e53ca18c
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 3acb71f3-3813-4bcd-8bdc-c831e53ca18c
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows object of forbidden types.
      metadata.gatekeeper.sh/title: Block Objects of Type
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblockobjectsoftype
    resourceVersion: "1746760531573423011"
    uid: d2044cf3-36c8-46d9-8a35-e76cf7bd090f
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockObjectsOfType
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              forbiddenTypes:
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8sblockobjectsoftype

        violation[{"msg": msg}] {
          objectType := input.review.object.type
          input.parameters.forbiddenTypes[_] = objectType
          msg := sprintf("Object of type: %v is not allowed", [objectType])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: d2044cf3-36c8-46d9-8a35-e76cf7bd090f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: d2044cf3-36c8-46d9-8a35-e76cf7bd090f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Prohibits Pod specs with `shareProcessNamespace` set to `true`.
        This avoids scenarios where all containers in a Pod share a PID namespace
        and can access each other's filesystem and memory.
      metadata.gatekeeper.sh/title: Block Process Namespace Sharing
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:17Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblockprocessnamespacesharing
    resourceVersion: "1746760550936815004"
    uid: edb8abc8-836a-4e4e-922b-cb567cf76f1f
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockProcessNamespaceSharing
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8sblockprocessnamespacesharing

        violation[{"msg": msg}] {
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          input.review.object.spec.shareProcessNamespace == true
          msg := "Process namespace sharing is not allowed"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: edb8abc8-836a-4e4e-922b-cb567cf76f1f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: edb8abc8-836a-4e4e-922b-cb567cf76f1f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Users should not be able to create Ingresses with a blank or wildcard
        (*) hostname since that would enable them to intercept traffic for other services
        in the cluster, even if they don't have access to those services.
      metadata.gatekeeper.sh/title: Block Wildcard Ingress
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:18Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sblockwildcardingress
    resourceVersion: "1746760551636703018"
    uid: 04b599d7-a39d-4e9f-afc5-c68dfa0adb03
  spec:
    crd:
      spec:
        names:
          kind: K8sBlockWildcardIngress
        validation:
          legacySchema: false
    targets:
    - rego: |
        package K8sBlockWildcardIngress

        contains_wildcard(hostname) = true {
          hostname == ""
        }

        contains_wildcard(hostname) = true {
          contains(hostname, "*")
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Ingress"
          # object.get is required to detect omitted host fields
          hostname := object.get(input.review.object.spec.rules[_], "host", "")
          contains_wildcard(hostname)
          msg := sprintf("Hostname '%v' is not allowed since it counts as a wildcard, which can be used to intercept traffic from other applications.", [hostname])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 04b599d7-a39d-4e9f-afc5-c68dfa0adb03
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 04b599d7-a39d-4e9f-afc5-c68dfa0adb03
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires containers to have an ephemeral storage limit set and constrains the limit to be within the specified maximum values.
        https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
      metadata.gatekeeper.sh/title: Container ephemeral storage limit
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:06Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8scontainerephemeralstoragelimit
    resourceVersion: "1746760512515583002"
    uid: d763fb6d-28c1-4414-bf0b-f20db966d11f
  spec:
    crd:
      spec:
        names:
          kind: K8sContainerEphemeralStorageLimit
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              ephemeral-storage:
                description: The maximum allowed ephemeral storage limit on a Pod,
                  exclusive.
                type: string
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8scontainerephemeralstoragelimit

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        missing(obj, field) = true {
          not obj[field]
        }

        missing(obj, field) = true {
          obj[field] == ""
        }

        has_field(object, field) = true {
            object[field]
        }

        # 10 ** 21
        storage_multiple("E") = 1000000000000000000000 { true }

        # 10 ** 18
        storage_multiple("P") = 1000000000000000000 { true }

        # 10 ** 15
        storage_multiple("T") = 1000000000000000 { true }

        # 10 ** 12
        storage_multiple("G") = 1000000000000 { true }

        # 10 ** 9
        storage_multiple("M") = 1000000000 { true }

        # 10 ** 6
        storage_multiple("k") = 1000000 { true }

        # 10 ** 3
        storage_multiple("") = 1000 { true }

        # Kubernetes accepts millibyte precision when it probably shouldn't.
        # https://github.com/kubernetes/kubernetes/issues/28741
        # 10 ** 0
        storage_multiple("m") = 1 { true }

        # 1000 * 2 ** 10
        storage_multiple("Ki") = 1024000 { true }

        # 1000 * 2 ** 20
        storage_multiple("Mi") = 1048576000 { true }

        # 1000 * 2 ** 30
        storage_multiple("Gi") = 1073741824000 { true }

        # 1000 * 2 ** 40
        storage_multiple("Ti") = 1099511627776000 { true }

        # 1000 * 2 ** 50
        storage_multiple("Pi") = 1125899906842624000 { true }

        # 1000 * 2 ** 60
        storage_multiple("Ei") = 1152921504606846976000 { true }

        get_suffix(storage) = suffix {
          not is_string(storage)
          suffix := ""
        }

        get_suffix(storage) = suffix {
          is_string(storage)
          count(storage) > 0
          suffix := substring(storage, count(storage) - 1, -1)
          storage_multiple(suffix)
        }

        get_suffix(storage) = suffix {
          is_string(storage)
          count(storage) > 1
          suffix := substring(storage, count(storage) - 2, -1)
          storage_multiple(suffix)
        }

        get_suffix(storage) = suffix {
          is_string(storage)
          count(storage) > 1
          not storage_multiple(substring(storage, count(storage) - 1, -1))
          not storage_multiple(substring(storage, count(storage) - 2, -1))
          suffix := ""
        }

        get_suffix(storage) = suffix {
          is_string(storage)
          count(storage) == 1
          not storage_multiple(substring(storage, count(storage) - 1, -1))
          suffix := ""
        }

        get_suffix(storage) = suffix {
          is_string(storage)
          count(storage) == 0
          suffix := ""
        }

        canonify_storage(orig) = new {
          is_number(orig)
          new := orig * 1000
        }

        canonify_storage(orig) = new {
          not is_number(orig)
          suffix := get_suffix(orig)
          raw := replace(orig, suffix, "")
          regex.match("^[0-9]+(\\.[0-9]+)?$", raw)
          new := to_number(raw) * storage_multiple(suffix)
        }

        violation[{"msg": msg}] {
          # spec.containers.resources.limits["ephemeral-storage"] field is immutable.
          not is_update(input.review)

          general_violation[{"msg": msg, "field": "containers"}]
        }

        violation[{"msg": msg}] {
          not is_update(input.review)
          general_violation[{"msg": msg, "field": "initContainers"}]
        }

        # Ephemeral containers not checked as it is not possible to set field.

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          storage_orig := container.resources.limits["ephemeral-storage"]
          not canonify_storage(storage_orig)
          msg := sprintf("container <%v> ephemeral-storage limit <%v> could not be parsed", [container.name, storage_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources
          msg := sprintf("container <%v> has no resource limits", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources.limits
          msg := sprintf("container <%v> has no resource limits", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.limits, "ephemeral-storage")
          msg := sprintf("container <%v> has no ephemeral-storage limit", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          storage_orig := container.resources.limits["ephemeral-storage"]
          storage := canonify_storage(storage_orig)
          max_storage_orig := input.parameters["ephemeral-storage"]
          max_storage := canonify_storage(max_storage_orig)
          storage > max_storage
          msg := sprintf("container <%v> ephemeral-storage limit <%v> is higher than the maximum allowed of <%v>", [container.name, storage_orig, max_storage_orig])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: d763fb6d-28c1-4414-bf0b-f20db966d11f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: d763fb6d-28c1-4414-bf0b-f20db966d11f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires containers to have memory and CPU limits set and constrains limits to be within the specified maximum values.
        https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
      metadata.gatekeeper.sh/title: Container Limits
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:11Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8scontainerlimits
    resourceVersion: "1746760537065103008"
    uid: bb46a8f1-4b2e-495b-975d-35a59098b235
  spec:
    crd:
      spec:
        names:
          kind: K8sContainerLimits
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              cpu:
                description: The maximum allowed cpu limit on a Pod, exclusive.
                type: string
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              memory:
                description: The maximum allowed memory limit on a Pod, exclusive.
                type: string
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8scontainerlimits

        import data.lib.exempt_container.is_exempt

        missing(obj, field) = true {
          not obj[field]
        }

        missing(obj, field) = true {
          obj[field] == ""
        }

        canonify_cpu(orig) = new {
          is_number(orig)
          new := orig * 1000
        }

        canonify_cpu(orig) = new {
          not is_number(orig)
          endswith(orig, "m")
          new := to_number(replace(orig, "m", ""))
        }

        canonify_cpu(orig) = new {
          not is_number(orig)
          not endswith(orig, "m")
          regex.match("^[0-9]+(\\.[0-9]+)?$", orig)
          new := to_number(orig) * 1000
        }

        # 10 ** 21
        mem_multiple("E") = 1000000000000000000000 { true }

        # 10 ** 18
        mem_multiple("P") = 1000000000000000000 { true }

        # 10 ** 15
        mem_multiple("T") = 1000000000000000 { true }

        # 10 ** 12
        mem_multiple("G") = 1000000000000 { true }

        # 10 ** 9
        mem_multiple("M") = 1000000000 { true }

        # 10 ** 6
        mem_multiple("k") = 1000000 { true }

        # 10 ** 3
        mem_multiple("") = 1000 { true }

        # Kubernetes accepts millibyte precision when it probably shouldn't.
        # https://github.com/kubernetes/kubernetes/issues/28741
        # 10 ** 0
        mem_multiple("m") = 1 { true }

        # 1000 * 2 ** 10
        mem_multiple("Ki") = 1024000 { true }

        # 1000 * 2 ** 20
        mem_multiple("Mi") = 1048576000 { true }

        # 1000 * 2 ** 30
        mem_multiple("Gi") = 1073741824000 { true }

        # 1000 * 2 ** 40
        mem_multiple("Ti") = 1099511627776000 { true }

        # 1000 * 2 ** 50
        mem_multiple("Pi") = 1125899906842624000 { true }

        # 1000 * 2 ** 60
        mem_multiple("Ei") = 1152921504606846976000 { true }

        get_suffix(mem) = suffix {
          not is_string(mem)
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 0
          suffix := substring(mem, count(mem) - 1, -1)
          mem_multiple(suffix)
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 1
          suffix := substring(mem, count(mem) - 2, -1)
          mem_multiple(suffix)
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 1
          not mem_multiple(substring(mem, count(mem) - 1, -1))
          not mem_multiple(substring(mem, count(mem) - 2, -1))
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) == 1
          not mem_multiple(substring(mem, count(mem) - 1, -1))
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) == 0
          suffix := ""
        }

        canonify_mem(orig) = new {
          is_number(orig)
          new := orig * 1000
        }

        canonify_mem(orig) = new {
          not is_number(orig)
          suffix := get_suffix(orig)
          raw := replace(orig, suffix, "")
          regex.match("^[0-9]+(\\.[0-9]+)?$", raw)
          new := to_number(raw) * mem_multiple(suffix)
        }

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "containers"}]
        }

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "initContainers"}]
        }

        # Ephemeral containers not checked as it is not possible to set field.

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          cpu_orig := container.resources.limits.cpu
          not canonify_cpu(cpu_orig)
          msg := sprintf("container <%v> cpu limit <%v> could not be parsed", [container.name, cpu_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          mem_orig := container.resources.limits.memory
          not canonify_mem(mem_orig)
          msg := sprintf("container <%v> memory limit <%v> could not be parsed", [container.name, mem_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources
          msg := sprintf("container <%v> has no resource limits", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources.limits
          msg := sprintf("container <%v> has no resource limits", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.limits, "cpu")
          msg := sprintf("container <%v> has no cpu limit", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.limits, "memory")
          msg := sprintf("container <%v> has no memory limit", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          cpu_orig := container.resources.limits.cpu
          cpu := canonify_cpu(cpu_orig)
          max_cpu_orig := input.parameters.cpu
          max_cpu := canonify_cpu(max_cpu_orig)
          cpu > max_cpu
          msg := sprintf("container <%v> cpu limit <%v> is higher than the maximum allowed of <%v>", [container.name, cpu_orig, max_cpu_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          mem_orig := container.resources.limits.memory
          mem := canonify_mem(mem_orig)
          max_mem_orig := input.parameters.memory
          max_mem := canonify_mem(max_mem_orig)
          mem > max_mem
          msg := sprintf("container <%v> memory limit <%v> is higher than the maximum allowed of <%v>", [container.name, mem_orig, max_mem_orig])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: bb46a8f1-4b2e-495b-975d-35a59098b235
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: bb46a8f1-4b2e-495b-975d-35a59098b235
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Sets a maximum ratio for container resource limits to requests.
        https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
      metadata.gatekeeper.sh/title: Container Ratios
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:23Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8scontainerratios
    resourceVersion: "1746760553270495004"
    uid: b4b163e6-4f0c-49f4-9e14-7176f8abc058
  spec:
    crd:
      spec:
        names:
          kind: K8sContainerRatios
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              cpuRatio:
                description: The maximum allowed ratio of `resources.limits.cpu` to
                  `resources.requests.cpu` on a container. If not specified, equal
                  to `ratio`.
                type: string
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              ratio:
                description: The maximum allowed ratio of `resources.limits` to `resources.requests`
                  on a container.
                type: string
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8scontainerratios

        import data.lib.exempt_container.is_exempt

        missing(obj, field) = true {
          not obj[field]
        }

        missing(obj, field) = true {
          obj[field] == ""
        }

        canonify_cpu(orig) = new {
          is_number(orig)
          new := orig * 1000
        }

        canonify_cpu(orig) = new {
          not is_number(orig)
          endswith(orig, "m")
          new := to_number(replace(orig, "m", ""))
        }

        canonify_cpu(orig) = new {
          not is_number(orig)
          not endswith(orig, "m")
          regex.match("^[0-9]+$", orig)
          new := to_number(orig) * 1000
        }

        canonify_cpu(orig) = new {
          not is_number(orig)
          not endswith(orig, "m")
          regex.match("^[0-9]+[.][0-9]+$", orig)
          new := to_number(orig) * 1000
        }

        # 10 ** 21
        mem_multiple("E") = 1000000000000000000000 { true }

        # 10 ** 18
        mem_multiple("P") = 1000000000000000000 { true }

        # 10 ** 15
        mem_multiple("T") = 1000000000000000 { true }

        # 10 ** 12
        mem_multiple("G") = 1000000000000 { true }

        # 10 ** 9
        mem_multiple("M") = 1000000000 { true }

        # 10 ** 6
        mem_multiple("k") = 1000000 { true }

        # 10 ** 3
        mem_multiple("") = 1000 { true }

        # Kubernetes accepts millibyte precision when it probably shouldn't.
        # https://github.com/kubernetes/kubernetes/issues/28741
        # 10 ** 0
        mem_multiple("m") = 1 { true }

        # 1000 * 2 ** 10
        mem_multiple("Ki") = 1024000 { true }

        # 1000 * 2 ** 20
        mem_multiple("Mi") = 1048576000 { true }

        # 1000 * 2 ** 30
        mem_multiple("Gi") = 1073741824000 { true }

        # 1000 * 2 ** 40
        mem_multiple("Ti") = 1099511627776000 { true }

        # 1000 * 2 ** 50
        mem_multiple("Pi") = 1125899906842624000 { true }

        # 1000 * 2 ** 60
        mem_multiple("Ei") = 1152921504606846976000 { true }

        get_suffix(mem) = suffix {
          not is_string(mem)
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 0
          suffix := substring(mem, count(mem) - 1, -1)
          mem_multiple(suffix)
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 1
          suffix := substring(mem, count(mem) - 2, -1)
          mem_multiple(suffix)
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 1
          not mem_multiple(substring(mem, count(mem) - 1, -1))
          not mem_multiple(substring(mem, count(mem) - 2, -1))
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) == 1
          not mem_multiple(substring(mem, count(mem) - 1, -1))
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) == 0
          suffix := ""
        }

        canonify_mem(orig) = new {
          is_number(orig)
          new := orig * 1000
        }

        canonify_mem(orig) = new {
          not is_number(orig)
          suffix := get_suffix(orig)
          raw := replace(orig, suffix, "")
          regex.match("^[0-9]+(\\.[0-9]+)?$", raw)
          new := to_number(raw) * mem_multiple(suffix)
        }

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "containers"}]
        }

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "initContainers"}]
        }

        # Ephemeral containers not checked as it is not possible to set field.

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          cpu_orig := container.resources.limits.cpu
          not canonify_cpu(cpu_orig)
          msg := sprintf("container <%v> cpu limit <%v> could not be parsed", [container.name, cpu_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          mem_orig := container.resources.limits.memory
          not canonify_mem(mem_orig)
          msg := sprintf("container <%v> memory limit <%v> could not be parsed", [container.name, mem_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          cpu_orig := container.resources.requests.cpu
          not canonify_cpu(cpu_orig)
          msg := sprintf("container <%v> cpu request <%v> could not be parsed", [container.name, cpu_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          mem_orig := container.resources.requests.memory
          not canonify_mem(mem_orig)
          msg := sprintf("container <%v> memory request <%v> could not be parsed", [container.name, mem_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources
          msg := sprintf("container <%v> has no resource limits", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources.limits
          msg := sprintf("container <%v> has no resource limits", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.limits, "cpu")
          msg := sprintf("container <%v> has no cpu limit", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.limits, "memory")
          msg := sprintf("container <%v> has no memory limit", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources.requests
          msg := sprintf("container <%v> has no resource requests", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.requests, "cpu")
          msg := sprintf("container <%v> has no cpu request", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.requests, "memory")
          msg := sprintf("container <%v> has no memory request", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          cpu_limits_orig := container.resources.limits.cpu
          cpu_limits := canonify_cpu(cpu_limits_orig)
          cpu_requests_orig := container.resources.requests.cpu
          cpu_requests := canonify_cpu(cpu_requests_orig)
          cpu_ratio := object.get(input.parameters, "cpuRatio", input.parameters.ratio)
          to_number(cpu_limits) > to_number(cpu_ratio) * to_number(cpu_requests)
          msg := sprintf("container <%v> cpu limit <%v> is higher than the maximum allowed ratio of <%v>", [container.name, cpu_limits_orig, cpu_ratio])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          mem_limits_orig := container.resources.limits.memory
          mem_requests_orig := container.resources.requests.memory
          mem_limits := canonify_mem(mem_limits_orig)
          mem_requests := canonify_mem(mem_requests_orig)
          mem_ratio := input.parameters.ratio
          to_number(mem_limits) > to_number(mem_ratio) * to_number(mem_requests)
          msg := sprintf("container <%v> memory limit <%v> is higher than the maximum allowed ratio of <%v>", [container.name, mem_limits_orig, mem_ratio])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b4b163e6-4f0c-49f4-9e14-7176f8abc058
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b4b163e6-4f0c-49f4-9e14-7176f8abc058
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires containers to have memory and CPU requests set and constrains requests to be within the specified maximum values.
        https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
      metadata.gatekeeper.sh/title: Container Requests
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:05Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8scontainerrequests
    resourceVersion: "1746760508093263021"
    uid: b4a5780b-f71e-4659-968f-7edde2371d3b
  spec:
    crd:
      spec:
        names:
          kind: K8sContainerRequests
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              cpu:
                description: The maximum allowed cpu request on a Pod, exclusive.
                type: string
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              memory:
                description: The maximum allowed memory request on a Pod, exclusive.
                type: string
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8scontainerrequests

        import data.lib.exempt_container.is_exempt

        missing(obj, field) = true {
          not obj[field]
        }

        missing(obj, field) = true {
          obj[field] == ""
        }

        canonify_cpu(orig) = new {
          is_number(orig)
          new := orig * 1000
        }

        canonify_cpu(orig) = new {
          not is_number(orig)
          endswith(orig, "m")
          new := to_number(replace(orig, "m", ""))
        }

        canonify_cpu(orig) = new {
          not is_number(orig)
          not endswith(orig, "m")
          regex.match("^[0-9]+(\\.[0-9]+)?$", orig)
          new := to_number(orig) * 1000
        }

        # 10 ** 21
        mem_multiple("E") = 1000000000000000000000 { true }

        # 10 ** 18
        mem_multiple("P") = 1000000000000000000 { true }

        # 10 ** 15
        mem_multiple("T") = 1000000000000000 { true }

        # 10 ** 12
        mem_multiple("G") = 1000000000000 { true }

        # 10 ** 9
        mem_multiple("M") = 1000000000 { true }

        # 10 ** 6
        mem_multiple("k") = 1000000 { true }

        # 10 ** 3
        mem_multiple("") = 1000 { true }

        # Kubernetes accepts millibyte precision when it probably shouldn't.
        # https://github.com/kubernetes/kubernetes/issues/28741
        # 10 ** 0
        mem_multiple("m") = 1 { true }

        # 1000 * 2 ** 10
        mem_multiple("Ki") = 1024000 { true }

        # 1000 * 2 ** 20
        mem_multiple("Mi") = 1048576000 { true }

        # 1000 * 2 ** 30
        mem_multiple("Gi") = 1073741824000 { true }

        # 1000 * 2 ** 40
        mem_multiple("Ti") = 1099511627776000 { true }

        # 1000 * 2 ** 50
        mem_multiple("Pi") = 1125899906842624000 { true }

        # 1000 * 2 ** 60
        mem_multiple("Ei") = 1152921504606846976000 { true }

        get_suffix(mem) = suffix {
          not is_string(mem)
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 0
          suffix := substring(mem, count(mem) - 1, -1)
          mem_multiple(suffix)
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 1
          suffix := substring(mem, count(mem) - 2, -1)
          mem_multiple(suffix)
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) > 1
          not mem_multiple(substring(mem, count(mem) - 1, -1))
          not mem_multiple(substring(mem, count(mem) - 2, -1))
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) == 1
          not mem_multiple(substring(mem, count(mem) - 1, -1))
          suffix := ""
        }

        get_suffix(mem) = suffix {
          is_string(mem)
          count(mem) == 0
          suffix := ""
        }

        canonify_mem(orig) = new {
          is_number(orig)
          new := orig * 1000
        }

        canonify_mem(orig) = new {
          not is_number(orig)
          suffix := get_suffix(orig)
          raw := replace(orig, suffix, "")
          regex.match("^[0-9]+(\\.[0-9]+)?$", raw)
          new := to_number(raw) * mem_multiple(suffix)
        }

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "containers"}]
        }

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "initContainers"}]
        }

        # Ephemeral containers not checked as it is not possible to set field.

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          cpu_orig := container.resources.requests.cpu
          not canonify_cpu(cpu_orig)
          msg := sprintf("container <%v> cpu request <%v> could not be parsed", [container.name, cpu_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          mem_orig := container.resources.requests.memory
          not canonify_mem(mem_orig)
          msg := sprintf("container <%v> memory request <%v> could not be parsed", [container.name, mem_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources
          msg := sprintf("container <%v> has no resource requests", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          not container.resources.requests
          msg := sprintf("container <%v> has no resource requests", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.requests, "cpu")
          msg := sprintf("container <%v> has no cpu request", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          missing(container.resources.requests, "memory")
          msg := sprintf("container <%v> has no memory request", [container.name])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          cpu_orig := container.resources.requests.cpu
          cpu := canonify_cpu(cpu_orig)
          max_cpu_orig := input.parameters.cpu
          max_cpu := canonify_cpu(max_cpu_orig)
          cpu > max_cpu
          msg := sprintf("container <%v> cpu request <%v> is higher than the maximum allowed of <%v>", [container.name, cpu_orig, max_cpu_orig])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          mem_orig := container.resources.requests.memory
          mem := canonify_mem(mem_orig)
          max_mem_orig := input.parameters.memory
          max_mem := canonify_mem(max_mem_orig)
          mem > max_mem
          msg := sprintf("container <%v> memory request <%v> is higher than the maximum allowed of <%v>", [container.name, mem_orig, max_mem_orig])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b4a5780b-f71e-4659-968f-7edde2371d3b
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b4a5780b-f71e-4659-968f-7edde2371d3b
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires container images of CronJobs to begin with a string from
        the specified list.
      metadata.gatekeeper.sh/title: CronJob Allowed Repositories
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:20Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8scronjoballowedrepos
    resourceVersion: "1746760552231103008"
    uid: 2d2f1f94-b1a0-49d6-8a14-8c2ddce0a049
  spec:
    crd:
      spec:
        names:
          kind: K8sCronJobAllowedRepos
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              repos:
                description: The list of prefixes a container image is allowed to
                  have.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8scronjoballowedrepos

        import future.keywords.in

        violation[{"msg": msg}] {
          allowedRepos := object.get(input, ["parameters", "repos"], set())

          some container in input.review.object.spec.jobTemplate.spec.template.spec.containers
          not strings.any_prefix_match(container.image, allowedRepos)
          msg := sprintf(
            "container <%v> has an invalid image repo <%v>, allowed repos are %v",
            [container.name, container.image, allowedRepos],
          )
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 2d2f1f94-b1a0-49d6-8a14-8c2ddce0a049
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 2d2f1f94-b1a0-49d6-8a14-8c2ddce0a049
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows associating ClusterRole and Role resources to the system:anonymous
        user and system:unauthenticated group.
      metadata.gatekeeper.sh/title: Disallow Anonymous Access
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:14Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sdisallowanonymous
    resourceVersion: "1746760549193695000"
    uid: dafcf52a-d7e7-4178-89a4-1a51de2e894e
  spec:
    crd:
      spec:
        names:
          kind: K8sDisallowAnonymous
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedRoles:
                description: The list of ClusterRoles and Roles that may be associated
                  with the `system:unauthenticated` group and `system:anonymous` user.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8sdisallowanonymous

        violation[{"msg": msg}] {
          not is_allowed(input.review.object.roleRef, input.parameters.allowedRoles)
          review(input.review.object.subjects[_])
          msg := sprintf("Unauthenticated user reference is not allowed in %v %v ", [input.review.object.kind, input.review.object.metadata.name])
        }

        is_allowed(role, allowedRoles) {
          role.name == allowedRoles[_]
        }

        review(subject) = true {
          subject.name == "system:unauthenticated"
        }

        review(subject) = true {
          subject.name == "system:anonymous"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: dafcf52a-d7e7-4178-89a4-1a51de2e894e
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: dafcf52a-d7e7-4178-89a4-1a51de2e894e
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallowed container repositories that begin with a string from
        the specified list.
      metadata.gatekeeper.sh/title: Disallowed Repositories
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:06Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sdisallowedrepos
    resourceVersion: "1746760513774687022"
    uid: 15571647-719c-4301-92a7-441717ba39c0
  spec:
    crd:
      spec:
        names:
          kind: K8sDisallowedRepos
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              repos:
                description: The list of prefixes a container image is not allowed
                  to have.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8sdisallowedrepos

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          image := container.image
          startswith(image, input.parameters.repos[_])
          msg := sprintf("container <%v> has an invalid image repo <%v>, disallowed repos are %v", [container.name, container.image, input.parameters.repos])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          image := container.image
          startswith(image, input.parameters.repos[_])
          msg := sprintf("initContainer <%v> has an invalid image repo <%v>, disallowed repos are %v", [container.name, container.image, input.parameters.repos])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.ephemeralContainers[_]
          image := container.image
          startswith(image, input.parameters.repos[_])
          msg := sprintf("ephemeralContainer <%v> has an invalid image repo <%v>, disallowed repos are %v", [container.name, container.image, input.parameters.repos])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 15571647-719c-4301-92a7-441717ba39c0
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 15571647-719c-4301-92a7-441717ba39c0
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Prohibits RoleBindings or ClusterRoleBindings with subjects matching
        any `disallowedSubjects` passed as parameters.
      metadata.gatekeeper.sh/title: Disallowed Rolebinding Subjects
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:06Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sdisallowedrolebindingsubjects
    resourceVersion: "1746760510635743010"
    uid: 9afa7b26-6f2e-46f9-815b-cf443ac4f271
  spec:
    crd:
      spec:
        names:
          kind: K8sDisallowedRoleBindingSubjects
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              disallowedSubjects:
                description: A list of subjects that cannot appear in a RoleBinding.
                items:
                  properties:
                    apiGroup:
                      description: The Kubernetes API group of the disallowed role
                        binding subject. Currently ignored.
                      type: string
                    kind:
                      description: The kind of the disallowed role binding subject.
                      type: string
                    name:
                      description: The name of the disallowed role binding subject.
                      type: string
                  type: object
                type: array
            type: object
    targets:
    - rego: |
        package k8sdisallowedrolebindingsubjects

        is_rolebinding_or_cluster_rolebinding(kind) {
          kind.group == "rbac.authorization.k8s.io"
          kinds := {"RoleBinding", "ClusterRoleBinding"}
          kinds[kind.kind]
        }

        violation[{"msg": msg}] {
          is_rolebinding_or_cluster_rolebinding(input.review.kind)
          disallowedSubject := input.parameters.disallowedSubjects[_]
          inputSubject := input.review.object.subjects[_]
          disallowedSubject.name == inputSubject.name
          disallowedSubject.kind == inputSubject.kind
          msg := sprintf("<%v> has disallowed kind <%v> and name <%v>", [input.review.object.metadata.name, inputSubject.kind, inputSubject.name])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 9afa7b26-6f2e-46f9-815b-cf443ac4f271
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 9afa7b26-6f2e-46f9-815b-cf443ac4f271
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires container images to have an image tag different from the ones in the specified list.
        https://kubernetes.io/docs/concepts/containers/images/#image-names
      metadata.gatekeeper.sh/title: Disallow tags
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sdisallowedtags
    resourceVersion: "1746760525458671001"
    uid: 9536b433-ffab-46b8-9a1f-478c915db06c
  spec:
    crd:
      spec:
        names:
          kind: K8sDisallowedTags
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptImages:
                description: 'Any container that uses an image that matches an entry
                  in this list will be excluded from enforcement. Prefix-matching
                  can be signified with `*`. For example: `my-image-*`. It is recommended
                  that users use the fully-qualified Docker image name (e.g. start
                  with a domain name) in order to avoid unexpectedly exempting images
                  from an untrusted repository.'
                items:
                  type: string
                type: array
              tags:
                description: Disallowed container image tags.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8sdisallowedtags

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg}] {
            container := input_containers[_]
            not is_exempt(container)
            tags := [tag_with_prefix | tag := input.parameters.tags[_]; tag_with_prefix := concat(":", ["", tag])]
            strings.any_suffix_match(container.image, tags)
            msg := sprintf("container <%v> uses a disallowed tag <%v>; disallowed tags are %v", [container.name, container.image, input.parameters.tags])
        }

        violation[{"msg": msg}] {
            container := input_containers[_]
            not is_exempt(container)
            not contains(container.image, ":")
            msg := sprintf("container <%v> didn't specify an image tag <%v>", [container.name, container.image])
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 9536b433-ffab-46b8-9a1f-478c915db06c
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 9536b433-ffab-46b8-9a1f-478c915db06c
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires that objects have the fields `spec.tty` and `spec.stdin`
        set to false or unset.
      metadata.gatekeeper.sh/title: Disallow Interactive TTY Containers
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:14Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sdisallowinteractivetty
    resourceVersion: "1746760547685727003"
    uid: f43510b8-b83c-43a0-bdcd-79ba0a5390d1
  spec:
    crd:
      spec:
        names:
          kind: K8sDisallowInteractiveTTY
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls use of fields related to gaining an interactive
              session. Corresponds to the `tty` and `stdin` fields in the Pod `spec.containers`,
              `spec.ephemeralContainers`, and `spec.initContainers`.
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8sdisallowinteractivetty

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            c := input_containers[_]
            not is_exempt(c)
            input_allow_interactive_fields(c)
            msg := sprintf("Containers using tty or stdin (%v) are not allowed running image: %v", [c.name, c.image])
        }

        input_allow_interactive_fields(c) {
            has_field(c, "stdin")
            not c.stdin == false
        }
        input_allow_interactive_fields(c) {
            has_field(c, "tty")
            not c.tty == false
        }
        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: f43510b8-b83c-43a0-bdcd-79ba0a5390d1
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: f43510b8-b83c-43a0-bdcd-79ba0a5390d1
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires that any `emptyDir` volumes specify a `sizeLimit`. Optionally,
        a `maxSizeLimit` parameter can be supplied in the constraint to specify a
        maximum allowable size limit.
      metadata.gatekeeper.sh/title: Empty Directory has Size Limit
      metadata.gatekeeper.sh/version: 1.0.5
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:14Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8semptydirhassizelimit
    resourceVersion: "1746760549242079003"
    uid: edcf2897-0fdd-4953-9415-3a2f94a71d3e
  spec:
    crd:
      spec:
        names:
          kind: K8sEmptyDirHasSizeLimit
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptVolumesRegex:
                description: Exempt Volume names as regex match.
                items:
                  type: string
                type: array
              maxSizeLimit:
                description: When set, the declared size limit for each volume must
                  be less than `maxSizeLimit`.
                type: string
            type: object
    targets:
    - rego: |
        package k8semptydirhassizelimit

        violation[{"msg": msg}] {
          some i
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          volume := input.review.object.spec.volumes[i]
          volume.emptyDir
          not volume.emptyDir.sizeLimit
          not is_exempt_volume(volume.name)
          msg := sprintf("emptyDir volume <%v> must have a size limit", [volume_identifier(volume, i)])
        }

        violation[{"msg": msg}] {
          some i
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          volume := input.review.object.spec.volumes[i]
          canonify_bytes(volume.emptyDir.sizeLimit) > canonify_bytes(input.parameters.maxSizeLimit)
          not is_exempt_volume(volume.name)
          msg := sprintf("emptyDir volume <%v> size limit <%v> exceeds maximum <%v>", [volume_identifier(volume, i), volume.emptyDir.sizeLimit, input.parameters.maxSizeLimit])
        }

        violation[{"msg": msg}] {
          some i
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          volume := input.review.object.spec.volumes[i]
          not is_number_or_e_notation(volume.emptyDir.sizeLimit)
          not is_number_with_suffix(volume.emptyDir.sizeLimit)
          not is_exempt_volume(volume.name)
          msg := sprintf("emptyDir volume <%v> size limit <%v> could not be parsed as bytes", [volume_identifier(volume, i), volume.emptyDir.sizeLimit])
        }

        violation[{"msg": msg}] {
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          not is_number_or_e_notation(input.parameters.maxSizeLimit)
          not is_number_with_suffix(input.parameters.maxSizeLimit)
          msg := sprintf("emptyDir volume max size limit <%v> could not be parsed as bytes", [input.parameters.maxSizeLimit])
        }

        readable_volume_name(name) {
          name != false
          name != null
          name != ""
          name
        }

        volume_identifier(volume, _) := name {
          readable_volume_name(volume.name)
          name := volume.name
        }

        volume_identifier(volume, i) := name {
          not readable_volume_name(volume.name)
          name := i
        }

        is_number_or_e_notation(n) {
          regex.match(`^[0-9]*(\.?[0-9]+)?(e[-+]?[0-9]+)?$`, sprintf("%v", [n]))
        }

        is_number_with_suffix(n) {
          regex.match(`^[0-9]+(\.[0-9]+)?[EePpTtGgMmKk]i?$`, sprintf("%v", [n]))
        }

        canonify_bytes(n) := n_bytes {
          is_number_or_e_notation(n)
          n_bytes := to_number(n)
        }

        canonify_bytes(n) := n_bytes {
          is_number_with_suffix(n)
          n_bytes := units.parse_bytes(sprintf("%vB", [n]))
        }

        is_exempt_volume(name) {
          parameters := object.get(input, "parameters", {})
          exemptVolumes := object.get(parameters, "exemptVolumesRegex", [])
          count(exemptVolumes) > 0
          exemptVolume := exemptVolumes[_]
          has_regex_match(name, exemptVolume)
        }

        has_regex_match(subject, exempt) {
          regex.match(exempt, subject)
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: edcf2897-0fdd-4953-9415-3a2f94a71d3e
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: edcf2897-0fdd-4953-9415-3a2f94a71d3e
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforces Cloud Armor configuration on BackendConfig resources
      metadata.gatekeeper.sh/title: Enforce Cloud Armor on BackendConfig Resources
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:21Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8senforcecloudarmorbackendconfig
    resourceVersion: "1746760552508431005"
    uid: 976df9ca-00f0-402c-afec-ceda8023b060
  spec:
    crd:
      spec:
        names:
          kind: K8sEnforceCloudArmorBackendConfig
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8senforcecloudarmorbackendconfig

        violation[{"msg": msg}] {
          input.review.kind.kind == "BackendConfig"
          is_null(input.review.object.spec.securityPolicy.name)
          msg := "Cloudarmor is not configured on the BackendConfig resource"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "BackendConfig"
          input.review.object.spec.securityPolicy.name == ""
          msg := "Cloudarmor is not configured on the BackendConfig resource"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "BackendConfig"
          not input.review.object.spec.securityPolicy.name
          msg := "Cloudarmor is not configured on the BackendConfig resource"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 976df9ca-00f0-402c-afec-ceda8023b060
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 976df9ca-00f0-402c-afec-ceda8023b060
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires the presence and operation of Config Management. Constraints
        using this `ConstraintTemplate` will be audit only regardless of `enforcementAction`
        value.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["configsync.gke.io"],
              "versions": ["v1beta1"],
              "kinds": ["RootSync"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Enforce Config Management
      metadata.gatekeeper.sh/version: 1.1.6
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:15Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8senforceconfigmanagement
    resourceVersion: "1746760549906335006"
    uid: 77a94391-d04b-4496-a033-33f8f62433e7
  spec:
    crd:
      spec:
        names:
          kind: K8sEnforceConfigManagement
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              requireDriftPrevention:
                default: false
                description: Require Config Sync drift prevention to prevent config
                  drift.
                type: boolean
              requireRootSync:
                default: false
                description: Require a Config Sync `RootSync` object for cluster config
                  management.
                type: boolean
            type: object
    targets:
    - rego: |
        package k8senforceconfigmanagement

        violation[{"msg": msg}] {
          input.review.kind.kind == "ConfigManagement"
          input.review.kind.group == "configmanagement.gke.io"

          # Audit Only, do not block as status is a derived value
          input.review.operation != "UPDATE"
          input.review.operation != "CREATE"
          health := object.get(input.review.object.status, "healthy", false)
          health == false
          msg := "Config Management operator is unhealthy. Check operator logs for more information."
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "ConfigManagement"
          input.review.kind.group == "configmanagement.gke.io"

          # Audit Only, do not block as preventDrift cannot be set directly
          input.review.operation != "UPDATE"
          input.review.operation != "CREATE"
          object.get(object.get(input.review.object, "spec", {}), "preventDrift", false) == false
          object.get(input.parameters, "requireDriftPrevention", false) == true
          msg := "Config Sync admission webhook is not enabled.  Enable to prevent configuration drift."
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "ConfigManagement"
          input.review.kind.group == "configmanagement.gke.io"

          # Audit Only, do not block as Config Sync is required to create a RootSync object
          input.review.operation != "UPDATE"
          input.review.operation != "CREATE"
          not cluster_has_rootsync(input.review)
          object.get(input.parameters, "requireRootSync", false) == true
          msg := "No Config Sync RootSync object detected.  Create to enforce cluster Config Management."
        }

        cluster_has_rootsync(_) {
          count(data.inventory.namespace[_][_].RootSync[_]) > 0
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 77a94391-d04b-4496-a033-33f8f62433e7
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 77a94391-d04b-4496-a033-33f8f62433e7
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Restricts Service externalIPs to an allowed list of IP addresses.
        https://kubernetes.io/docs/concepts/services-networking/service/#external-ips
      metadata.gatekeeper.sh/title: External IPs
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:10Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sexternalips
    resourceVersion: "1746760535718703006"
    uid: a938aa25-bacc-420f-b154-10fae79c8261
  spec:
    crd:
      spec:
        names:
          kind: K8sExternalIPs
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedIPs:
                description: An allow-list of external IP addresses.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8sexternalips

        violation[{"msg": msg}] {
          input.review.kind.kind == "Service"
          input.review.kind.group == ""
          allowedIPs := {ip | ip := input.parameters.allowedIPs[_]}
          externalIPs := {ip | ip := input.review.object.spec.externalIPs[_]}
          forbiddenIPs := externalIPs - allowedIPs
          count(forbiddenIPs) > 0
          msg := sprintf("service has forbidden external IPs: %v", [forbiddenIPs])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: a938aa25-bacc-420f-b154-10fae79c8261
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: a938aa25-bacc-420f-b154-10fae79c8261
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallow the following scenarios when deploying `HorizontalPodAutoscalers`
        1. Deployment of HorizontalPodAutoscalers with `.spec.minReplicas` or `.spec.maxReplicas`
        outside the ranges defined in the constraint 2. Deployment of HorizontalPodAutoscalers
        where the difference between `.spec.minReplicas` and `.spec.maxReplicas` is
        less than the configured `minimumReplicaSpread` 3. Deployment of HorizontalPodAutoscalers
        that do not reference a valid `scaleTargetRef` (e.g. Deployment, ReplicationController,
        ReplicaSet, StatefulSet).
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups":["apps"],
              "versions": ["v1"],
              "kinds": ["Deployment"]
            },
            {
              "groups":["apps"],
              "versions": ["v1"],
              "kinds": ["StatefulSet"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Horizontal Pod Autoscaler
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:24Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8shorizontalpodautoscaler
    resourceVersion: "1746760554061887012"
    uid: 0877854a-0bee-416c-98be-b4f2a8393ac2
  spec:
    crd:
      spec:
        names:
          kind: K8sHorizontalPodAutoscaler
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              enforceScaleTargetRef:
                description: If set to true it validates the HPA scaleTargetRef exists
                type: boolean
              minimumReplicaSpread:
                description: If configured it enforces the minReplicas and maxReplicas
                  in an HPA must have a spread of at least this many replicas
                type: integer
              ranges:
                description: Allowed ranges for numbers of replicas.  Values are inclusive.
                items:
                  description: A range of allowed replicas.  Values are inclusive.
                  properties:
                    max_replicas:
                      description: The maximum number of replicas allowed, inclusive.
                      type: integer
                    min_replicas:
                      description: The minimum number of replicas allowed, inclusive.
                      type: integer
                  type: object
                type: array
            type: object
    targets:
    - rego: "package k8shorizontalpodautoscaler\n\nviolation[{\"msg\": msg}] {\n  input.review.kind.kind
        == \"HorizontalPodAutoscaler\"\n  hpa := input.review.object\n\n  not input_replica_limit(hpa)\n
        \ msg := sprintf(\"The %v <%v> minReplicas %v or maxReplicas %v is not allowed:
        %v. Allowed ranges: %v\", [hpa.kind, hpa.metadata.name, hpa.spec.minReplicas,
        hpa.spec.maxReplicas, input.parameters.ranges])\n}\n\nviolation[{\"msg\":
        msg}] {\n  input.review.kind.kind == \"HorizontalPodAutoscaler\"\n  hpa :=
        input.review.object\n\n  not input_replica_spread(hpa)\n  \n  msg := sprintf(\"The
        %v <%v> is configured with minReplicas %v and maxReplicas %v which is a spread
        of %v replica(s). The spread must be at least %v replica(s)\", [hpa.kind,
        hpa.metadata.name, hpa.spec.minReplicas, hpa.spec.maxReplicas, hpa.spec.maxReplicas
        - hpa.spec.minReplicas, input.parameters.minimumReplicaSpread])\n}\n\nviolation[{\"msg\":
        msg}] {\n  input.review.kind.kind == \"HorizontalPodAutoscaler\"\n  hpa :=
        input.review.object\n  input.parameters.enforceScaleTargetRef\n  \n  not data.inventory.namespace[hpa.metadata.namespace][hpa.spec.scaleTargetRef.apiVersion][hpa.spec.scaleTargetRef.kind][hpa.spec.scaleTargetRef.name]\n
        \ msg := sprintf(\"The HorizontalPodAutoscaler <%v> has a scaleTargetRef of
        <%v/%v> but it does not exist. The scaleTargetRef for the HorizontalPodAutoscaler
        must exist\", [hpa.metadata.name, hpa.spec.scaleTargetRef.kind, hpa.spec.scaleTargetRef.name])\n}\n\ninput_replica_limit(hpa)
        {\n    count(input.parameters.ranges) > 0\n    range := input.parameters.ranges[_]\n
        \   value_within_range(range, hpa.spec.minReplicas, hpa.spec.maxReplicas)\n}\n\nvalue_within_range(range,
        min_provided, max_provided) {\n    range.min_replicas <= min_provided\n    range.max_replicas
        >= max_provided\n}\n\ninput_replica_spread(hpa) {\n    input.parameters.minimumReplicaSpread\n
        \   (hpa.spec.maxReplicas - hpa.spec.minReplicas) >= input.parameters.minimumReplicaSpread\n}\n"
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 0877854a-0bee-416c-98be-b4f2a8393ac2
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 0877854a-0bee-416c-98be-b4f2a8393ac2
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires Ingress resources to be HTTPS only.  Ingress resources must include the `kubernetes.io/ingress.allow-http` annotation, set to `false`. By default a valid TLS {} configuration is required, this can be made optional by setting the `tlsOptional` parameter to `true`.
        https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
      metadata.gatekeeper.sh/title: HTTPS Only
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:22Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8shttpsonly
    resourceVersion: "1746760553020207007"
    uid: 25e434fe-2112-47ef-8350-6d50f257d296
  spec:
    crd:
      spec:
        names:
          kind: K8sHttpsOnly
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Requires Ingress resources to be HTTPS only.  Ingress resources
              must include the `kubernetes.io/ingress.allow-http` annotation, set
              to `false`. By default a valid TLS {} configuration is required, this
              can be made optional by setting the `tlsOptional` parameter to `true`.
            properties:
              tlsOptional:
                description: When set to `true` the TLS {} is optional, defaults to
                  false.
                type: boolean
            type: object
    targets:
    - rego: |
        package k8shttpsonly

        violation[{"msg": msg}] {
          input.review.object.kind == "Ingress"
          regex.match("^(extensions|networking.k8s.io)/", input.review.object.apiVersion)
          ingress := input.review.object
          not https_complete(ingress)
          not tls_is_optional
          msg := sprintf("Ingress should be https. tls configuration and allow-http=false annotation are required for %v", [ingress.metadata.name])
        }

        violation[{"msg": msg}] {
          input.review.object.kind == "Ingress"
          regex.match("^(extensions|networking.k8s.io)/", input.review.object.apiVersion)
          ingress := input.review.object
          not annotation_complete(ingress)
          tls_is_optional
          msg := sprintf("Ingress should be https. The allow-http=false annotation is required for %v", [ingress.metadata.name])
        }

        https_complete(ingress) = true {
          ingress.spec["tls"]
          count(ingress.spec.tls) > 0
          ingress.metadata.annotations["kubernetes.io/ingress.allow-http"] == "false"
        }

        annotation_complete(ingress) = true {
          ingress.metadata.annotations["kubernetes.io/ingress.allow-http"] == "false"
        }

        tls_is_optional {
          parameters := object.get(input, "parameters", {})
          object.get(parameters, "tlsOptional", false) == true
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 25e434fe-2112-47ef-8350-6d50f257d296
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 25e434fe-2112-47ef-8350-6d50f257d296
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires container images to contain a digest.
        https://kubernetes.io/docs/concepts/containers/images/
      metadata.gatekeeper.sh/title: Image Digests
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:10Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8simagedigests
    resourceVersion: "1746760536866623010"
    uid: a9c4ce1a-01c8-445b-8144-1d756dd15ea9
  spec:
    crd:
      spec:
        names:
          kind: K8sImageDigests
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: |-
              Requires container images to contain a digest.
              https://kubernetes.io/docs/concepts/containers/images/
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8simagedigests

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt(container)
          not regex.match("@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+", container.image)
          msg := sprintf("container <%v> uses an image without a digest <%v>", [container.name, container.image])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          not is_exempt(container)
          not regex.match("@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+", container.image)
          msg := sprintf("initContainer <%v> uses an image without a digest <%v>", [container.name, container.image])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.ephemeralContainers[_]
          not is_exempt(container)
          not regex.match("@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+", container.image)
          msg := sprintf("ephemeralContainer <%v> uses an image without a digest <%v>", [container.name, container.image])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: a9c4ce1a-01c8-445b-8144-1d756dd15ea9
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: a9c4ce1a-01c8-445b-8144-1d756dd15ea9
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: 'Requires Pods using local storage (`emptyDir` or `hostPath`) to
        have the annotation `"cluster-autoscaler.kubernetes.io/safe-to-evict": "true"`.
        Cluster Autoscaler will not delete Pods without this annotation.'
      metadata.gatekeeper.sh/title: Local Storage Requires Safe to Evict
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:18Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8slocalstoragerequiresafetoevict
    resourceVersion: "1746760551396447001"
    uid: 361df72d-88f6-48be-b9cd-e2678cd89bd7
  spec:
    crd:
      spec:
        names:
          kind: K8sLocalStorageRequireSafeToEvict
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8slocalstoragerequiresafetoevict

        has_local_storage(volumes) {
          volumes[_].emptyDir
        }

        has_local_storage(volumes) {
          volumes[_].hostPath
        }

        violation[{"msg": msg}] {
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          has_local_storage(input.review.object.spec.volumes)
          not input.review.object.metadata.annotations["cluster-autoscaler.kubernetes.io/safe-to-evict"] == "true"
          msg := "Annotation cluster-autoscaler.kubernetes.io/safe-to-evict must be present and set to true"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 361df72d-88f6-48be-b9cd-e2678cd89bd7
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 361df72d-88f6-48be-b9cd-e2678cd89bd7
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Promotes Pod stability by requiring that all containers' requested
        memory exactly equals the memory limit, so that Pods are never in a state
        where memory usage exceeds the requested amount. Otherwise, Kubernetes can
        terminate Pods requesting extra memory if memory is needed on the node.
      metadata.gatekeeper.sh/title: Memory Request Equals Limit
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:12Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8smemoryrequestequalslimit
    resourceVersion: "1746760541439039013"
    uid: 8641465d-1761-49ce-9e6c-8c5c75ac9da4
  spec:
    crd:
      spec:
        names:
          kind: K8sMemoryRequestEqualsLimit
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptContainersRegex:
                description: Exempt Container names as regex match.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8smemoryrequestequalslimit

        missing_or_empty(obj, field) {
          not obj[field]
        }

        missing_or_empty(obj, field) {
          obj[field] == ""
        }

        missing_or_empty(obj, field) {
          obj[field] == {}
        }

        violation[{"msg": msg}] {
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          field_violation[{"field": "containers", "msg": msg}]
        }

        violation[{"msg": msg}] {
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          field_violation[{"field": "initContainers", "msg": msg}]
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          missing_or_empty(container.resources.requests, "memory")
          not is_exempt_container(container.name)
          msg := sprintf("container <%v> must have a memory request", [container.name])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          missing_or_empty(container, "resources")
          not is_exempt_container(container.name)
          msg := sprintf("container <%v> has no resources", [container.name])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          missing_or_empty(container.resources, "limits")
          not is_exempt_container(container.name)
          msg := sprintf("container <%v> has no resource limits", [container.name])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          missing_or_empty(container.resources, "requests")
          not is_exempt_container(container.name)
          msg := sprintf("container <%v> has no resource requests", [container.name])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          missing_or_empty(container.resources.limits, "memory")
          not is_exempt_container(container.name)
          msg := sprintf("container <%v> has no memory limit", [container.name])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          mem_lim := canonify_bytes(container.resources.limits.memory)
          mem_req := canonify_bytes(container.resources.requests.memory)
          mem_req != mem_lim
          not is_exempt_container(container.name)
          msg := sprintf("Container <%v> memory request <%v> must exactly equal limit <%v>", [container.name, container.resources.requests.memory, container.resources.limits.memory])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          not is_number_or_e_notation(container.resources.limits.memory)
          not is_number_with_suffix(container.resources.limits.memory)
          not is_exempt_container(container.name)
          msg := sprintf("Container <%v> memory limit <%v> could not be parsed as bytes", [container.name, container.resources.limits.memory])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          container := input.review.object.spec[field][_]
          not is_number_or_e_notation(container.resources.requests.memory)
          not is_number_with_suffix(container.resources.requests.memory)
          not is_exempt_container(container.name)
          msg := sprintf("Container <%v> memory request <%v> could not be parsed as bytes", [container.name, container.resources.requests.memory])
        }

        is_number_or_e_notation(n) {
          regex.match(`^[0-9]*(\.?[0-9]+)?(e[-+]?[0-9]+)?$`, sprintf("%v", [n]))
        }

        is_number_with_suffix(n) {
          regex.match(`^[0-9]+(\.[0-9]+)?[EePpTtGgMmKk]i?$`, sprintf("%v", [n]))
        }

        canonify_bytes(n) := n_bytes {
          is_number_or_e_notation(n)
          n_bytes := to_number(n)
        }

        canonify_bytes(n) := n_bytes {
          is_number_with_suffix(n)
          n_bytes := units.parse_bytes(sprintf("%vB", [n]))
        }

        is_exempt_container(name) {
          parameters := object.get(input, "parameters", {})
          exemptContainers := object.get(parameters, "exemptContainersRegex", [])
          count(exemptContainers) > 0
          exemptContainer := exemptContainers[_]
          has_regex_match(name, exemptContainer)
        }

        has_regex_match(subject, exempt) {
          regex.match(exempt, subject)
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8641465d-1761-49ce-9e6c-8c5c75ac9da4
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8641465d-1761-49ce-9e6c-8c5c75ac9da4
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: 'Prohibits secrets as environment variables in Pod container definitions.
        Use mounted secret files in data volumes instead: https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod'
      metadata.gatekeeper.sh/title: No Environment Variable Secrets
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:16Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8snoenvvarsecrets
    resourceVersion: "1746760549978751006"
    uid: da340504-43f0-4a5e-b7f0-45c6046471ff
  spec:
    crd:
      spec:
        names:
          kind: K8sNoEnvVarSecrets
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8snoenvvarsecrets

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          container := input.review.object.spec.containers[_]
          env_var := container.env[_]
          env_var.valueFrom.secretKeyRef
          msg := sprintf("Container <%v> has secret defined as environment variable", [container.name])
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          initContainer := input.review.object.spec.initContainers[_]
          env_var := initContainer.env[_]
          env_var.valueFrom.secretKeyRef
          msg := sprintf("initContainer <%v> has secret defined as environment variable", [initContainer.name])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: da340504-43f0-4a5e-b7f0-45c6046471ff
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: da340504-43f0-4a5e-b7f0-45c6046471ff
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Prohibits the creation of known resources that expose workloads to external IPs. This includes Istio Gateway resources and Kubernetes Ingress resources. Kubernetes services are also disallowed unless they meet the following criteria:
        Any Service of type `LoadBalancer` in Google Cloud must have a `"networking.gke.io/load-balancer-type": "Internal"` annotation.
        Any Service of type `LoadBalancer` in AWS must have a `service.beta.kubernetes.io/aws-load-balancer-internal: "true` annotation.
        Any "external IPs" (external to the cluster) bound to the Service must be a member of a range of internal CIDRs as provided to the constraint.
      metadata.gatekeeper.sh/title: No External Services
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:24Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8snoexternalservices
    resourceVersion: "1746760553997375021"
    uid: 8e4ccaee-bedd-4dd0-a1d2-ffedf36ba89a
  spec:
    crd:
      spec:
        names:
          kind: K8sNoExternalServices
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              cloudPlatform:
                description: The hosting cloud platform. Only `GCP` and `AWS` are
                  supported currently.
                type: string
              internalCIDRs:
                description: 'A list of CIDRs that are only accessible internally,
                  for example: `10.3.27.0/24`. Which IP ranges are internal-only is
                  determined by the underlying network infrastructure.'
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8snoexternalservices

        import future.keywords.in

        violation[{"msg": msg}] {
          input.review.kind.kind == "Ingress"
          regex.match(`^(extensions|networking.k8s.io)$`, input.review.kind.group)
          msg := "No external service exposure is allowed via ingress"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Gateway"
          input.review.kind.group == "networking.istio.io"
          msg := "Creation of networking.istio.io/Gateway resources is not allowed"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Service"
          input.review.kind.group == ""
          input.review.object.spec.type == "LoadBalancer"
          not is_valid_service
          msg := "Creating services of type `LoadBalancer` without Internal annotation or not setting `service.beta.kubernetes.io/aws-load-balancer-internal` to true is not allowed"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Service"
          input.review.kind.group == ""
          ip := input.review.object.spec.externalIPs[_]
          is_external_ip(ip)
          msg := sprintf("Service has an external IP exposed: `%v`", [ip])
        }

        is_external_ip(ip) {
          cidr_membership := [i | cidr := input.parameters.internalCIDRs[_]; i := net.cidr_contains(cidr, ip)]
          not true in cidr_membership
        }

        is_valid_service {
          # GKE versions < 1.17
          input.review.object.metadata.annotations["cloud.google.com/load-balancer-type"] == "Internal"
          is_hosted_on_gcp
        }

        is_valid_service {
          # GKE versions >= 1.17
          input.review.object.metadata.annotations["networking.gke.io/load-balancer-type"] == "Internal"
          is_hosted_on_gcp
        }

        is_valid_service {
          input.review.object.metadata.annotations["service.beta.kubernetes.io/aws-load-balancer-internal"] == "true"
          input.parameters.cloudPlatform == "AWS"
        }

        is_hosted_on_gcp {
          not input.parameters.cloudPlatform
        }

        is_hosted_on_gcp {
          input.parameters.cloudPlatform == "GCP"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8e4ccaee-bedd-4dd0-a1d2-ffedf36ba89a
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8e4ccaee-bedd-4dd0-a1d2-ffedf36ba89a
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Disallow the following scenarios when deploying PodDisruptionBudgets or resources that implement the replica subresource (e.g. Deployment, ReplicationController, ReplicaSet, StatefulSet): 1. Deployment of PodDisruptionBudgets with .spec.maxUnavailable == 0 2. Deployment of PodDisruptionBudgets with .spec.minAvailable == .spec.replicas of the resource with replica subresource This will prevent PodDisruptionBudgets from blocking voluntary disruptions such as node draining.
        https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups":["policy"],
              "versions": ["v1"],
              "kinds": ["PodDisruptionBudget"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Pod Disruption Budget
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8spoddisruptionbudget
    resourceVersion: "1746760525721935009"
    uid: 515dcc72-b295-474f-80c1-f9634ae8c533
  spec:
    crd:
      spec:
        names:
          kind: K8sPodDisruptionBudget
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8spoddisruptionbudget

        violation[{"msg": msg}] {
          input.review.kind.kind == "PodDisruptionBudget"
          pdb := input.review.object

          not valid_pdb_max_unavailable(pdb)
          msg := sprintf(
            "PodDisruptionBudget <%v> has maxUnavailable of 0, only positive integers are allowed for maxUnavailable",
            [pdb.metadata.name],
          )
        }

        violation[{"msg": msg}] {
          obj := input.review.object
          pdb := data.inventory.namespace[obj.metadata.namespace]["policy/v1"].PodDisruptionBudget[_]

          matchLabels := { [label, value] | some label; value := pdb.spec.selector.matchLabels[label] }
          labels := { [label, value] | some label; value := obj.spec.selector.matchLabels[label] }
          count(matchLabels - labels) == 0

          not valid_pdb_max_unavailable(pdb)
          msg := sprintf(
            "%v <%v> has been selected by PodDisruptionBudget <%v> but has maxUnavailable of 0, only positive integers are allowed for maxUnavailable",
            [obj.kind, obj.metadata.name, pdb.metadata.name],
          )
        }

        violation[{"msg": msg}] {
          obj := input.review.object
          pdb := data.inventory.namespace[obj.metadata.namespace]["policy/v1"].PodDisruptionBudget[_]

          matchLabels := { [label, value] | some label; value := pdb.spec.selector.matchLabels[label] }
          labels := { [label, value] | some label; value := obj.spec.selector.matchLabels[label] }
          count(matchLabels - labels) == 0

          not valid_pdb_min_available(obj, pdb)
          msg := sprintf(
            "%v <%v> has %v replica(s) but PodDisruptionBudget <%v> has minAvailable of %v, PodDisruptionBudget count should always be lower than replica(s), and not used when replica(s) is set to 1",
            [obj.kind, obj.metadata.name, obj.spec.replicas, pdb.metadata.name, pdb.spec.minAvailable],
          )
        }

        valid_pdb_min_available(obj, pdb) {
          # default to -1 if minAvailable is not set so valid_pdb_min_available is always true
          # for objects with >= 0 replicas. If minAvailable defaults to >= 0, objects with
          # replicas field might violate this constraint if they are equal to the default set here
          min_available := object.get(pdb.spec, "minAvailable", -1)
          obj.spec.replicas > min_available
        }

        valid_pdb_max_unavailable(pdb) {
          # default to 1 if maxUnavailable is not set so valid_pdb_max_unavailable always returns true.
          # If maxUnavailable defaults to 0, it violates this constraint because all pods needs to be
          # available and no pods can be evicted voluntarily
          max_unavailable := object.get(pdb.spec, "maxUnavailable", 1)
          max_unavailable > 0
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 515dcc72-b295-474f-80c1-f9634ae8c533
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 515dcc72-b295-474f-80c1-f9634ae8c533
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires that containers are not best-effort (by setting cpu and
        memory requests) and following burstable best practices (memory request must
        exactly equal limit).  Optionally, annotation keys can be configured to permit
        skipping the various validations.
      metadata.gatekeeper.sh/title: Requires Containers are not Best-effort and Following
        Burstable Best Practices
      metadata.gatekeeper.sh/version: 1.0.5
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:06Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spodresourcesbestpractices
    resourceVersion: "1746760510381919012"
    uid: b0733ca9-43ea-4589-b2c0-74e05983e4f3
  spec:
    crd:
      spec:
        names:
          kind: K8sPodResourcesBestPractices
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptImages:
                description: A list of exempt Images.
                items:
                  type: string
                type: array
              skipBestEffortValidationAnnotationKey:
                description: Optional annotation key to skip best-effort container
                  validation.
                type: string
              skipBurstableValidationAnnotationKey:
                description: Optional annotation key to skip burstable container validation.
                type: string
              skipResourcesBestPracticesValidationAnnotationKey:
                description: Optional annotation key to skip both best-effort and
                  burstable validation.
                type: string
            type: object
    targets:
    - rego: |
        package k8spodresourcesbestpractices

        violation[{"msg": msg}] {
          skip_validation("skipResourcesBestPracticesValidationAnnotationKey")
          input.review.kind.group == ""
          input.review.kind.kind == "Pod"
          field_violation[{"field": {"containers", "initContainers"}[_], "msg": msg}]
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          skip_validation("skipBestEffortValidationAnnotationKey")
          container := input.review.object.spec[field][_]
          not is_exempt_image(container)
          types := {"cpu", "memory"}[_]
          object.get(container, ["resources", "requests", types], "") == ""
          object.get(container, ["resources", "limits", types], "") == ""
          msg := sprintf("Container <%v> must set <%v> request.", [container.name, types])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          skip_validation("skipBurstableValidationAnnotationKey")
          container := input.review.object.spec[field][_]
          not is_exempt_image(container)
          not object.get(container, ["resources", "requests", "memory"], "") == ""
          object.get(container, ["resources", "limits", "memory"], "") == ""
          msg := sprintf("Container <%v> must set memory limit. Memory limit must equal memory request. Consider setting an extra buffer to avoid OOM Errors.", [container.name])
        }

        field_violation[{"msg": msg, "field": field}] {
          some field
          skip_validation("skipBurstableValidationAnnotationKey")
          container := input.review.object.spec[field][_]
          not is_exempt_image(container)
          mem_req := object.get(container, ["resources", "requests", "memory"], null)
          mem_lim := object.get(container, ["resources", "limits", "memory"], null)
          canonify_bytes(mem_req) != canonify_bytes(mem_lim)
          msg := sprintf("Container <%v> memory request <%v> must exactly equal memory limit <%v>.", [container.name, mem_req, mem_lim])
        }

        canonify_bytes(n) := n_bytes {
          is_number_or_e_notation(n)
          n_bytes := to_number(n)
        }

        canonify_bytes(n) := n_bytes {
          is_number_with_suffix(n)
          n_bytes := units.parse_bytes(sprintf("%vB", [n]))
        }

        is_number_or_e_notation(n) {
          regex.match(`^[0-9]*(\.?[0-9]+)?(e[-+]?[0-9]+)?$`, sprintf("%v", [n]))
        }

        is_number_with_suffix(n) {
          regex.match(`^[0-9]+(\.[0-9]+)?[EePpTtGgMmKk]i?$`, sprintf("%v", [n]))
        }

        skip_validation(conf_key) {
          annotation_key := object.get(input, ["parameters", conf_key], null)
          not input.review.object.metadata.annotations[annotation_key] == "true"
        }

        is_exempt_image(container) {
          exempt_image := input.parameters.exemptImages[_]
          not endswith(exempt_image, "*")
          container.image == exempt_image
        }

        is_exempt_image(container) {
          exempt_image := input.parameters.exemptImages[_]
          endswith(exempt_image, "*")
          startswith(container.image, trim_suffix(exempt_image, "*"))
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b0733ca9-43ea-4589-b2c0-74e05983e4f3
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b0733ca9-43ea-4589-b2c0-74e05983e4f3
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires all Pods to define securityContext. Requires all containers
        defined in Pods to have a SecurityContext defined at the Pod or container
        level.
      metadata.gatekeeper.sh/title: Pods Require Security Context
      metadata.gatekeeper.sh/version: 1.1.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:19Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spodsrequiresecuritycontext
    resourceVersion: "1746760551917823024"
    uid: be971da1-1c69-4e69-bbd8-9de52458216e
  spec:
    crd:
      spec:
        names:
          kind: K8sPodsRequireSecurityContext
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptImages:
                description: A list of exempt Images.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8spodsrequiresecuritycontext

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          container := input.review.object.spec.containers[_]
          not is_exempt_image(container)
          has_empty_security_context(container)
          has_empty_security_context(input.review.object.spec)
          msg := "securityContext must be defined for all Pod containers"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          initContainer := input.review.object.spec.initContainers[_]
          not is_exempt_image(initContainer)
          has_empty_security_context(initContainer)
          has_empty_security_context(input.review.object.spec)
          msg := "securityContext must be defined for all Pod initContainers"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          not input.review.object.spec.containers
          not input.review.object.spec.initContainers
          has_empty_security_context(input.review.object.spec)
          msg := "securityContext must be defined for Pod"
        }

        has_empty_security_context(spec) {
          spec.securityContext == {}
        }

        has_empty_security_context(spec) {
          not spec.securityContext
        }

        has_empty_security_context(spec) {
          spec.securityContext == null
        }

        is_exempt_image(container) {
          exempt_image := input.parameters.exemptImages[_]
          not endswith(exempt_image, "*")
          container.image == exempt_image
        }

        is_exempt_image(container) {
          exempt_image := input.parameters.exemptImages[_]
          endswith(exempt_image, "*")
          startswith(container.image, trim_suffix(exempt_image, "*"))
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: be971da1-1c69-4e69-bbd8-9de52458216e
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: be971da1-1c69-4e69-bbd8-9de52458216e
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires that Roles and ClusterRoles not set resource access to a wildcard '"*"' value
        except for the exempted Roles and ClusterRoles provided as exemptions.
        Does not restrict wildcard access to subresources, such as '"*/status"'.
      metadata.gatekeeper.sh/title: Prohibit Role Wildcard Access
      metadata.gatekeeper.sh/version: 1.0.5
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:07Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sprohibitrolewildcardaccess
    resourceVersion: "1746760519010479022"
    uid: b4d1d91c-a622-47b3-bdb8-20141c0ba0e1
  spec:
    crd:
      spec:
        names:
          kind: K8sProhibitRoleWildcardAccess
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptions:
                description: The list of exempted Roles and/or ClusterRoles name that
                  are allowed to set  resource access to a wildcard.
                properties:
                  clusterRoles:
                    items:
                      properties:
                        name:
                          description: The name of the ClusterRole to be exempted.
                          type: string
                        regexMatch:
                          description: The flag to allow a regular expression based
                            match on the name.
                          type: boolean
                      type: object
                    type: array
                  roles:
                    items:
                      properties:
                        name:
                          description: The name of the Role to be exempted.
                          type: string
                        namespace:
                          description: The namespace of the Role to be exempted.
                          type: string
                      type: object
                    type: array
                type: object
            type: object
    targets:
    - rego: |
        package k8sprohibitrolewildcardaccess

        import future.keywords.in

        violation[{"msg": msg}] {
          some field
          i := input
          has_not_exempted_cluster_roles(input.review.kind, input.review.object.metadata, i)
          has_not_exempted_roles(input.review.kind, input.review.object.metadata, i)
          rule := input.review.object.rules[_]
          "*" in rule[field]
          msg := sprintf("<%v> has rule <%v> wildcard match", [input.review.object.metadata.name, field])
        }

        has_not_exempted_cluster_roles(_, _, i) {
          not i.parameters.exemptions.clusterRoles
        }

        has_not_exempted_cluster_roles(kind, cluster_role_metadata, i) {
          not cluster_role_is_exempted(kind, cluster_role_metadata, i.parameters.exemptions.clusterRoles)
        }

        cluster_role_is_exempted(kind, cluster_role_metadata, exempted_cluster_roles) {
          count(exempted_cluster_roles) > 0
          kind.kind == "ClusterRole"
          kind.group == "rbac.authorization.k8s.io"
          cluster_role := exempted_cluster_roles[_]
          has_exact_or_regex_match(cluster_role, cluster_role_metadata)
        }

        has_exact_or_regex_match(exemptedCluster_role, subjectCluster_role) {
          exemptedCluster_role.regexMatch == true
          regex.match(exemptedCluster_role.name, subjectCluster_role.name)
        }

        has_exact_or_regex_match(exemptedCluster_role, subjectCluster_role) {
          not exemptedCluster_role.regexMatch == true
          exemptedCluster_role.name == subjectCluster_role.name
        }

        has_not_exempted_roles(_, _, i) {
          not i.parameters.exemptions.roles
        }

        has_not_exempted_roles(kind, role_metadata, i) {
          not role_is_exempted(kind, role_metadata, i.parameters.exemptions.roles)
        }

        role_is_exempted(kind, role_metadata, exempted_roles) {
          count(exempted_roles) > 0
          kind.kind == "Role"
          kind.group == "rbac.authorization.k8s.io"
          role := exempted_roles[_]
          role.name == role_metadata.name
          role.namespace == role_metadata.namespace
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b4d1d91c-a622-47b3-bdb8-20141c0ba0e1
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b4d1d91c-a622-47b3-bdb8-20141c0ba0e1
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls the user and group IDs of the container and some volumes.
        Corresponds to the `runAsUser`, `runAsGroup`, `supplementalGroups`, and `fsGroup`
        fields in a PodSecurityPolicy. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups
      metadata.gatekeeper.sh/title: Allowed Users
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:16Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspallowedusers
    resourceVersion: "1746760550402207020"
    uid: 1075fb00-e28d-43dd-8282-c73bb522ae90
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPAllowedUsers
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls the user and group IDs of the container and some
              volumes. Corresponds to the `runAsUser`, `runAsGroup`, `supplementalGroups`,
              and `fsGroup` fields in a PodSecurityPolicy. For more information, see
              https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              fsGroup:
                description: Controls the fsGroup values that are allowed in a Pod
                  or container-level SecurityContext.
                properties:
                  ranges:
                    description: A list of group ID ranges affected by the rule.
                    items:
                      description: The range of group IDs affected by the rule.
                      properties:
                        max:
                          description: The maximum group ID in the range, inclusive.
                          type: integer
                        min:
                          description: The minimum group ID in the range, inclusive.
                          type: integer
                      type: object
                    type: array
                  rule:
                    description: A strategy for applying the fsGroup restriction.
                    enum:
                    - MustRunAs
                    - MayRunAs
                    - RunAsAny
                    type: string
                type: object
              runAsGroup:
                description: Controls which group ID values are allowed in a Pod or
                  container-level SecurityContext.
                properties:
                  ranges:
                    description: A list of group ID ranges affected by the rule.
                    items:
                      description: The range of group IDs affected by the rule.
                      properties:
                        max:
                          description: The maximum group ID in the range, inclusive.
                          type: integer
                        min:
                          description: The minimum group ID in the range, inclusive.
                          type: integer
                      type: object
                    type: array
                  rule:
                    description: A strategy for applying the runAsGroup restriction.
                    enum:
                    - MustRunAs
                    - MayRunAs
                    - RunAsAny
                    type: string
                type: object
              runAsUser:
                description: Controls which user ID values are allowed in a Pod or
                  container-level SecurityContext.
                properties:
                  ranges:
                    description: A list of user ID ranges affected by the rule.
                    items:
                      description: The range of user IDs affected by the rule.
                      properties:
                        max:
                          description: The maximum user ID in the range, inclusive.
                          type: integer
                        min:
                          description: The minimum user ID in the range, inclusive.
                          type: integer
                      type: object
                    type: array
                  rule:
                    description: A strategy for applying the runAsUser restriction.
                    enum:
                    - MustRunAs
                    - MustRunAsNonRoot
                    - RunAsAny
                    type: string
                type: object
              supplementalGroups:
                description: Controls the supplementalGroups values that are allowed
                  in a Pod or container-level SecurityContext.
                properties:
                  ranges:
                    description: A list of group ID ranges affected by the rule.
                    items:
                      description: The range of group IDs affected by the rule.
                      properties:
                        max:
                          description: The maximum group ID in the range, inclusive.
                          type: integer
                        min:
                          description: The minimum group ID in the range, inclusive.
                          type: integer
                      type: object
                    type: array
                  rule:
                    description: A strategy for applying the supplementalGroups restriction.
                    enum:
                    - MustRunAs
                    - MayRunAs
                    - RunAsAny
                    type: string
                type: object
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspallowedusers

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg}] {
          # runAsUser, runAsGroup, supplementalGroups, fsGroup fields are immutable.
          not is_update(input.review)

          fields := ["runAsUser", "runAsGroup", "supplementalGroups", "fsGroup"]
          field := fields[_]
          container := input_containers[_]
          not is_exempt(container)
          msg := get_type_violation(field, container)
        }

        get_type_violation(field, container) = msg {
          field == "runAsUser"
          params := input.parameters[field]
          msg := get_user_violation(params, container)
        }

        get_type_violation(field, container) = msg {
          field != "runAsUser"
          params := input.parameters[field]
          msg := get_violation(field, params, container)
        }

        # RunAsUser (separate due to "MustRunAsNonRoot")
        get_user_violation(params, container) = msg {
          rule := params.rule
          provided_user := get_field_value("runAsUser", container, input.review)
          not accept_users(rule, provided_user)
          msg := sprintf("Container %v is attempting to run as disallowed user %v. Allowed runAsUser: %v", [container.name, provided_user, params])
        }

        get_user_violation(params, container) = msg {
          not get_field_value("runAsUser", container, input.review)
          params.rule = "MustRunAs"
          msg := sprintf("Container %v is attempting to run without a required securityContext/runAsUser", [container.name])
        }

        get_user_violation(params, container) = msg {
          params.rule = "MustRunAsNonRoot"
          not get_field_value("runAsUser", container, input.review)
          not get_field_value("runAsNonRoot", container, input.review)
          msg := sprintf("Container %v is attempting to run without a required securityContext/runAsNonRoot or securityContext/runAsUser != 0", [container.name])
        }

        accept_users("RunAsAny", _)

        accept_users("MustRunAsNonRoot", provided_user) := provided_user != 0

        accept_users("MustRunAs", provided_user) := res  {
          ranges := input.parameters.runAsUser.ranges
          res := is_in_range(provided_user, ranges)
        }

        # Group Options
        get_violation(field, params, container) = msg {
          rule := params.rule
          provided_value := get_field_value(field, container, input.review)
          not is_array(provided_value)
          not accept_value(rule, provided_value, params.ranges)
          msg := sprintf("Container %v is attempting to run as disallowed group %v. Allowed %v: %v", [container.name, provided_value, field, params])
        }
        # SupplementalGroups is array value
        get_violation(field, params, container) = msg {
          rule := params.rule
          array_value := get_field_value(field, container, input.review)
          is_array(array_value)
          provided_value := array_value[_]
          not accept_value(rule, provided_value, params.ranges)
          msg := sprintf("Container %v is attempting to run with disallowed supplementalGroups %v. Allowed %v: %v", [container.name, array_value, field, params])
        }

        get_violation(field, params, container) = msg {
          not get_field_value(field, container, input.review)
          params.rule == "MustRunAs"
          msg := sprintf("Container %v is attempting to run without a required securityContext/%v. Allowed %v: %v", [container.name, field, field, params])
        }

        accept_value("RunAsAny", _, _)

        accept_value("MayRunAs", provided_value, ranges) := is_in_range(provided_value, ranges)

        accept_value("MustRunAs", provided_value, ranges) := is_in_range(provided_value, ranges)


        # If container level is provided, that takes precedence
        get_field_value(field, container, _) := get_seccontext_field(field, container)

        # If no container level exists, use pod level
        get_field_value(field, container, review) = out {
          not has_seccontext_field(field, container)
          review.kind.kind == "Pod"
          pod_value := get_seccontext_field(field, review.object.spec)
          out := pod_value
        }

        # Helper Functions
        is_in_range(val, ranges) = res {
          matching := {1 | val >= ranges[j].min; val <= ranges[j].max}
          res := count(matching) > 0
        }

        has_seccontext_field(field, obj) {
          get_seccontext_field(field, obj)
        }

        has_seccontext_field(field, obj) {
          get_seccontext_field(field, obj) == false
        }

        get_seccontext_field(field, obj) = out {
          out = obj.securityContext[field]
        }

        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
          c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 1075fb00-e28d-43dd-8282-c73bb522ae90
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 1075fb00-e28d-43dd-8282-c73bb522ae90
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls restricting escalation to root privileges. Corresponds
        to the `allowPrivilegeEscalation` field in a PodSecurityPolicy. For more information,
        see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation
      metadata.gatekeeper.sh/title: Allow Privilege Escalation in Container
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:13Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspallowprivilegeescalationcontainer
    resourceVersion: "1746760544839583002"
    uid: ae497315-c968-44db-b2d3-ced55f65c645
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPAllowPrivilegeEscalationContainer
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls restricting escalation to root privileges. Corresponds
              to the `allowPrivilegeEscalation` field in a PodSecurityPolicy. For
              more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspallowprivilegeescalationcontainer

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            # spec.containers.securityContext.allowPrivilegeEscalation field is immutable.
            not is_update(input.review)

            c := input_containers[_]
            not is_exempt(c)
            input_allow_privilege_escalation(c)
            msg := sprintf("Privilege escalation container is not allowed: %v", [c.name])
        }

        input_allow_privilege_escalation(c) {
            not has_field(c, "securityContext")
        }
        input_allow_privilege_escalation(c) {
            not c.securityContext.allowPrivilegeEscalation == false
        }
        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: ae497315-c968-44db-b2d3-ced55f65c645
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: ae497315-c968-44db-b2d3-ced55f65c645
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Configures an allow-list of AppArmor profiles for use by containers.
        This corresponds to specific annotations applied to a PodSecurityPolicy. For
        information on AppArmor, see https://kubernetes.io/docs/tutorials/clusters/apparmor/
      metadata.gatekeeper.sh/title: App Armor
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:13Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspapparmor
    resourceVersion: "1746760544455151024"
    uid: 2483118d-d77d-4f0f-9332-937d218cae06
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPAppArmor
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Configures an allow-list of AppArmor profiles for use by
              containers. This corresponds to specific annotations applied to a PodSecurityPolicy.
              For information on AppArmor, see https://kubernetes.io/docs/tutorials/clusters/apparmor/
            properties:
              allowedProfiles:
                description: 'An array of AppArmor profiles. Examples: `runtime/default`,
                  `unconfined`.'
                items:
                  type: string
                type: array
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspapparmor

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            metadata := input.review.object.metadata
            container := input_containers[_]
            not is_exempt(container)
            not input_apparmor_allowed(container, metadata)
            msg := sprintf("AppArmor profile is not allowed, pod: %v, container: %v. Allowed profiles: %v", [input.review.object.metadata.name, container.name, input.parameters.allowedProfiles])
        }

        input_apparmor_allowed(container, metadata) {
            get_annotation_for(container, metadata) == input.parameters.allowedProfiles[_]
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }

        get_annotation_for(container, metadata) = out {
            out = metadata.annotations[sprintf("container.apparmor.security.beta.kubernetes.io/%v", [container.name])]
        }
        get_annotation_for(container, metadata) = out {
            not metadata.annotations[sprintf("container.apparmor.security.beta.kubernetes.io/%v", [container.name])]
            out = "runtime/default"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 2483118d-d77d-4f0f-9332-937d218cae06
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 2483118d-d77d-4f0f-9332-937d218cae06
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls the ability of any Pod to enable automountServiceAccountToken.
      metadata.gatekeeper.sh/title: Automount Service Account Token for Pod
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspautomountserviceaccounttokenpod
    resourceVersion: "1746760526142351001"
    uid: be2ddca7-0165-4d42-a8ac-fd3e6db1163a
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPAutomountServiceAccountTokenPod
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls the ability of any Pod to enable automountServiceAccountToken.
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8sautomountserviceaccounttoken

        import data.lib.exclude_update.is_update

        violation[{"msg": msg}] {
            # spec.automountServiceAccountToken and spec.containers.volumeMounts fields are immutable.
            not is_update(input.review)

            obj := input.review.object
            mountServiceAccountToken(obj.spec)
            msg := sprintf("Automounting service account token is disallowed, pod: %v", [obj.metadata.name])
        }

        mountServiceAccountToken(spec) {
            spec.automountServiceAccountToken == true
        }

        # if there is no automountServiceAccountToken spec, check on volumeMount in containers. Service Account token is mounted on /var/run/secrets/kubernetes.io/serviceaccount
        # https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#serviceaccount-admission-controller
        mountServiceAccountToken(spec) {
            not has_key(spec, "automountServiceAccountToken")
            "/var/run/secrets/kubernetes.io/serviceaccount" == input_containers[_].volumeMounts[_].mountPath
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }

        # Ephemeral containers not checked as it is not possible to set field.

        has_key(x, k) {
            _ = x[k]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: be2ddca7-0165-4d42-a8ac-fd3e6db1163a
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: be2ddca7-0165-4d42-a8ac-fd3e6db1163a
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls Linux capabilities on containers. Corresponds to the `allowedCapabilities`
        and `requiredDropCapabilities` fields in a PodSecurityPolicy. For more information,
        see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#capabilities
      metadata.gatekeeper.sh/title: Capabilities
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:13Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspcapabilities
    resourceVersion: "1746760545895599002"
    uid: 8dbcbbfd-d9b1-41d2-a923-6a72624ede68
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPCapabilities
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls Linux capabilities on containers. Corresponds to
              the `allowedCapabilities` and `requiredDropCapabilities` fields in a
              PodSecurityPolicy. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#capabilities
            properties:
              allowedCapabilities:
                description: A list of Linux capabilities that can be added to a container.
                items:
                  type: string
                type: array
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              requiredDropCapabilities:
                description: A list of Linux capabilities that are required to be
                  dropped from a container.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package capabilities

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg}] {
          # spec.containers.securityContext.capabilities field is immutable.
          not is_update(input.review)

          container := input.review.object.spec.containers[_]
          not is_exempt(container)
          has_disallowed_capabilities(container)
          msg := sprintf("container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
        }

        violation[{"msg": msg}] {
          not is_update(input.review)
          container := input.review.object.spec.containers[_]
          not is_exempt(container)
          missing_drop_capabilities(container)
          msg := sprintf("container <%v> is not dropping all required capabilities. Container must drop all of %v or \"ALL\"", [container.name, input.parameters.requiredDropCapabilities])
        }

        violation[{"msg": msg}] {
          not is_update(input.review)
          container := input.review.object.spec.initContainers[_]
          not is_exempt(container)
          has_disallowed_capabilities(container)
          msg := sprintf("init container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
        }

        violation[{"msg": msg}] {
          not is_update(input.review)
          container := input.review.object.spec.initContainers[_]
          not is_exempt(container)
          missing_drop_capabilities(container)
          msg := sprintf("init container <%v> is not dropping all required capabilities. Container must drop all of %v or \"ALL\"", [container.name, input.parameters.requiredDropCapabilities])
        }

        violation[{"msg": msg}] {
          not is_update(input.review)
          container := input.review.object.spec.ephemeralContainers[_]
          not is_exempt(container)
          has_disallowed_capabilities(container)
          msg := sprintf("ephemeral container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
        }

        violation[{"msg": msg}] {
          not is_update(input.review)
          container := input.review.object.spec.ephemeralContainers[_]
          not is_exempt(container)
          missing_drop_capabilities(container)
          msg := sprintf("ephemeral container <%v> is not dropping all required capabilities. Container must drop all of %v or \"ALL\"", [container.name, input.parameters.requiredDropCapabilities])
        }

        has_disallowed_capabilities(container) {
          allowed := {c | c := lower(input.parameters.allowedCapabilities[_])}
          not allowed["*"]
          capabilities := {c | c := lower(container.securityContext.capabilities.add[_])}

          count(capabilities - allowed) > 0
        }

        missing_drop_capabilities(container) {
          must_drop := {c | c := lower(input.parameters.requiredDropCapabilities[_])}
          all := {"all"}
          dropped := {c | c := lower(container.securityContext.capabilities.drop[_])}

          count(must_drop - dropped) > 0
          count(all - dropped) > 0
        }

        get_default(obj, param, _) := obj[param]

        get_default(obj, param, _default) := _default {
          not obj[param]
          not obj[param] == false
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8dbcbbfd-d9b1-41d2-a923-6a72624ede68
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8dbcbbfd-d9b1-41d2-a923-6a72624ede68
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls the allowlist of FlexVolume drivers. Corresponds to the
        `allowedFlexVolumes` field in PodSecurityPolicy. For more information, see
        https://kubernetes.io/docs/concepts/policy/pod-security-policy/#flexvolume-drivers
      metadata.gatekeeper.sh/title: FlexVolumes
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:12Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspflexvolumes
    resourceVersion: "1746760540865247016"
    uid: a6173802-a487-4c63-bac9-32f15c68fc93
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPFlexVolumes
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls the allowlist of FlexVolume drivers. Corresponds
              to the `allowedFlexVolumes` field in PodSecurityPolicy. For more information,
              see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#flexvolume-drivers
            properties:
              allowedFlexVolumes:
                description: An array of AllowedFlexVolume objects.
                items:
                  properties:
                    driver:
                      description: The name of the FlexVolume driver.
                      type: string
                  type: object
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8spspflexvolumes

        import data.lib.exclude_update.is_update

        violation[{"msg": msg, "details": {}}] {
            # spec.volumes field is immutable.
            not is_update(input.review)

            volume := input_flexvolumes[_]
            not input_flexvolumes_allowed(volume)
            msg := sprintf("FlexVolume %v is not allowed, pod: %v. Allowed drivers: %v", [volume, input.review.object.metadata.name, input.parameters.allowedFlexVolumes])
        }

        input_flexvolumes_allowed(volume) {
            input.parameters.allowedFlexVolumes[_].driver == volume.flexVolume.driver
        }

        input_flexvolumes[v] {
            v := input.review.object.spec.volumes[_]
            has_field(v, "flexVolume")
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: a6173802-a487-4c63-bac9-32f15c68fc93
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: a6173802-a487-4c63-bac9-32f15c68fc93
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls the `sysctl` profile used by containers. Corresponds to
        the `allowedUnsafeSysctls` and `forbiddenSysctls` fields in a PodSecurityPolicy.
        When specified, any sysctl not in the `allowedSysctls` parameter is considered
        to be forbidden. The `forbiddenSysctls` parameter takes precedence over the
        `allowedSysctls` parameter. For more information, see https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
      metadata.gatekeeper.sh/title: Forbidden Sysctls
      metadata.gatekeeper.sh/version: 1.1.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:19Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspforbiddensysctls
    resourceVersion: "1746760551981583002"
    uid: 06a61b6f-c1b5-49fe-807c-ad4ae509c12c
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPForbiddenSysctls
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls the `sysctl` profile used by containers. Corresponds
              to the `allowedUnsafeSysctls` and `forbiddenSysctls` fields in a PodSecurityPolicy.
              When specified, any sysctl not in the `allowedSysctls` parameter is
              considered to be forbidden. The `forbiddenSysctls` parameter takes precedence
              over the `allowedSysctls` parameter. For more information, see https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
            properties:
              allowedSysctls:
                description: An allow-list of sysctls. `*` allows all sysctls not
                  listed in the `forbiddenSysctls` parameter.
                items:
                  type: string
                type: array
              forbiddenSysctls:
                description: A disallow-list of sysctls. `*` forbids all sysctls.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8spspforbiddensysctls

        import data.lib.exclude_update.is_update

        # Block if forbidden
        violation[{"msg": msg, "details": {}}] {
            # spec.securityContext.sysctls field is immutable.
            not is_update(input.review)

            sysctl := input.review.object.spec.securityContext.sysctls[_].name
            forbidden_sysctl(sysctl)
            msg := sprintf("The sysctl %v is not allowed, pod: %v. Forbidden sysctls: %v", [sysctl, input.review.object.metadata.name, input.parameters.forbiddenSysctls])
        }

        # Block if not explicitly allowed
        violation[{"msg": msg, "details": {}}] {
            not is_update(input.review)
            sysctl := input.review.object.spec.securityContext.sysctls[_].name
            not allowed_sysctl(sysctl)
            msg := sprintf("The sysctl %v is not explicitly allowed, pod: %v. Allowed sysctls: %v", [sysctl, input.review.object.metadata.name, input.parameters.allowedSysctls])
        }

        # * may be used to forbid all sysctls
        forbidden_sysctl(_) {
            input.parameters.forbiddenSysctls[_] == "*"
        }

        forbidden_sysctl(sysctl) {
            input.parameters.forbiddenSysctls[_] == sysctl
        }

        forbidden_sysctl(sysctl) {
            forbidden := input.parameters.forbiddenSysctls[_]
            endswith(forbidden, "*")
            startswith(sysctl, trim_suffix(forbidden, "*"))
        }

        # * may be used to allow all sysctls
        allowed_sysctl(_) {
            input.parameters.allowedSysctls[_] == "*"
        }

        allowed_sysctl(sysctl) {
            input.parameters.allowedSysctls[_] == sysctl
        }

        allowed_sysctl(sysctl) {
            allowed := input.parameters.allowedSysctls[_]
            endswith(allowed, "*")
            startswith(sysctl, trim_suffix(allowed, "*"))
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 06a61b6f-c1b5-49fe-807c-ad4ae509c12c
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 06a61b6f-c1b5-49fe-807c-ad4ae509c12c
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls allocating an FSGroup that owns the Pod's volumes. Corresponds
        to the `fsGroup` field in a PodSecurityPolicy. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
      metadata.gatekeeper.sh/title: FS Group
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:14Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspfsgroup
    resourceVersion: "1746760548865311012"
    uid: df0d2939-97da-4abd-bec6-45aa40994f9c
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPFSGroup
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls allocating an FSGroup that owns the Pod's volumes.
              Corresponds to the `fsGroup` field in a PodSecurityPolicy. For more
              information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
            properties:
              ranges:
                description: GID ranges affected by the rule.
                items:
                  properties:
                    max:
                      description: The maximum GID in the range, inclusive.
                      type: integer
                    min:
                      description: The minimum GID in the range, inclusive.
                      type: integer
                  type: object
                type: array
              rule:
                description: An FSGroup rule name.
                enum:
                - MayRunAs
                - MustRunAs
                - RunAsAny
                type: string
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8spspfsgroup

        import data.lib.exclude_update.is_update

        violation[{"msg": msg, "details": {}}] {
            # spec.securityContext.fsGroup field is immutable.
            not is_update(input.review)

            spec := input.review.object.spec
            not input_fsGroup_allowed(spec)
            msg := sprintf("The provided pod spec fsGroup is not allowed, pod: %v. Allowed fsGroup: %v", [input.review.object.metadata.name, input.parameters])
        }

        input_fsGroup_allowed(_) {
            # RunAsAny - No range is required. Allows any fsGroup ID to be specified.
            input.parameters.rule == "RunAsAny"
        }
        input_fsGroup_allowed(spec) {
            # MustRunAs - Validates pod spec fsgroup against all ranges
            input.parameters.rule == "MustRunAs"
            fg := spec.securityContext.fsGroup
            count(input.parameters.ranges) > 0
            range := input.parameters.ranges[_]
            value_within_range(range, fg)
        }
        input_fsGroup_allowed(spec) {
            # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
            input.parameters.rule == "MayRunAs"
            not has_field(spec, "securityContext")
        }
        input_fsGroup_allowed(spec) {
            # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
            input.parameters.rule == "MayRunAs"
            not spec.securityContext.fsGroup
        }
        input_fsGroup_allowed(spec) {
            # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
            input.parameters.rule == "MayRunAs"
            fg := spec.securityContext.fsGroup
            count(input.parameters.ranges) > 0
            range := input.parameters.ranges[_]
            value_within_range(range, fg)
        }
        value_within_range(range, value) {
            range.min <= value
            range.max >= value
        }
        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: df0d2939-97da-4abd-bec6-45aa40994f9c
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: df0d2939-97da-4abd-bec6-45aa40994f9c
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls usage of the host filesystem. Corresponds to the `allowedHostPaths`
        field in a PodSecurityPolicy. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
      metadata.gatekeeper.sh/title: Host Filesystem
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:20Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spsphostfilesystem
    resourceVersion: "1746760552156895023"
    uid: d3447256-b912-4557-abe0-5d087330aaca
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPHostFilesystem
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls usage of the host filesystem. Corresponds to the
              `allowedHostPaths` field in a PodSecurityPolicy. For more information,
              see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
            properties:
              allowedHostPaths:
                description: An array of hostpath objects, representing paths and
                  read/write configuration.
                items:
                  properties:
                    pathPrefix:
                      description: The path prefix that the host volume must match.
                      type: string
                    readOnly:
                      description: 'when set to true, any container volumeMounts matching
                        the pathPrefix must include `readOnly: true`.'
                      type: boolean
                  type: object
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8spsphostfilesystem

        import data.lib.exclude_update.is_update

        violation[{"msg": msg, "details": {}}] {
            # spec.volumes field is immutable.
            not is_update(input.review)

            volume := input_hostpath_volumes[_]
            allowedPaths := get_allowed_paths(input)
            input_hostpath_violation(allowedPaths, volume)
            msg := sprintf("HostPath volume %v is not allowed, pod: %v. Allowed path: %v", [volume, input.review.object.metadata.name, allowedPaths])
        }

        input_hostpath_violation(allowedPaths, _) {
            # An empty list means all host paths are blocked
            allowedPaths == []
        }
        input_hostpath_violation(allowedPaths, volume) {
            not input_hostpath_allowed(allowedPaths, volume)
        }

        get_allowed_paths(arg) = out {
            not arg.parameters
            out = []
        }
        get_allowed_paths(arg) = out {
            not arg.parameters.allowedHostPaths
            out = []
        }
        get_allowed_paths(arg) = out {
            out = arg.parameters.allowedHostPaths
        }

        input_hostpath_allowed(allowedPaths, volume) {
            allowedHostPath := allowedPaths[_]
            path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
            not allowedHostPath.readOnly == true
        }

        input_hostpath_allowed(allowedPaths, volume) {
            allowedHostPath := allowedPaths[_]
            path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
            allowedHostPath.readOnly
            not writeable_input_volume_mounts(volume.name)
        }

        writeable_input_volume_mounts(volume_name) {
            container := input_containers[_]
            mount := container.volumeMounts[_]
            mount.name == volume_name
            not mount.readOnly
        }

        # This allows "/foo", "/foo/", "/foo/bar" etc., but
        # disallows "/fool", "/etc/foo" etc.
        path_matches(prefix, path) {
            a := path_array(prefix)
            b := path_array(path)
            prefix_matches(a, b)
        }
        path_array(p) = out {
            p != "/"
            out := split(trim(p, "/"), "/")
        }
        # This handles the special case for "/", since
        # split(trim("/", "/"), "/") == [""]
        path_array("/") = []

        prefix_matches(a, b) {
            count(a) <= count(b)
            not any_not_equal_upto(a, b, count(a))
        }

        any_not_equal_upto(a, b, n) {
            a[i] != b[i]
            i < n
        }

        input_hostpath_volumes[v] {
            v := input.review.object.spec.volumes[_]
            has_field(v, "hostPath")
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: d3447256-b912-4557-abe0-5d087330aaca
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: d3447256-b912-4557-abe0-5d087330aaca
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows sharing of host PID and IPC namespaces by pod containers.
        Corresponds to the `hostPID` and `hostIPC` fields in a PodSecurityPolicy.
        For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
      metadata.gatekeeper.sh/title: Host Namespace
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:17Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spsphostnamespace
    resourceVersion: "1746760550839407006"
    uid: a5e44fb3-99ce-495f-b378-bb0c908d0572
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPHostNamespace
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Disallows sharing of host PID and IPC namespaces by pod containers.
              Corresponds to the `hostPID` and `hostIPC` fields in a PodSecurityPolicy.
              For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8spsphostnamespace

        import data.lib.exclude_update.is_update

        violation[{"msg": msg, "details": {}}] {
            # spec.hostPID and spec.hostIPC fields are immutable.
            not is_update(input.review)

            input_share_hostnamespace(input.review.object)
            msg := sprintf("Sharing the host namespace is not allowed: %v", [input.review.object.metadata.name])
        }

        input_share_hostnamespace(o) {
            o.spec.hostPID
        }
        input_share_hostnamespace(o) {
            o.spec.hostIPC
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: a5e44fb3-99ce-495f-b378-bb0c908d0572
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: a5e44fb3-99ce-495f-b378-bb0c908d0572
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls usage of host network namespace by pod containers. Specific
        ports must be specified. Corresponds to the `hostNetwork` and `hostPorts`
        fields in a PodSecurityPolicy. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
      metadata.gatekeeper.sh/title: Host Networking Ports
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:05Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spsphostnetworkingports
    resourceVersion: "1746760509277359005"
    uid: 713ba07e-a37a-4250-b43f-7dd9026f15ff
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPHostNetworkingPorts
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls usage of host network namespace by pod containers.
              Specific ports must be specified. Corresponds to the `hostNetwork` and
              `hostPorts` fields in a PodSecurityPolicy. For more information, see
              https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              hostNetwork:
                description: Determines if the policy allows the use of HostNetwork
                  in the pod spec.
                type: boolean
              max:
                description: The end of the allowed port range, inclusive.
                type: integer
              min:
                description: The start of the allowed port range, inclusive.
                type: integer
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spsphostnetworkingports

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            # spec.hostNetwork field is immutable.
            not is_update(input.review)

            input_share_hostnetwork(input.review.object)
            msg := sprintf("The specified hostNetwork and hostPort are not allowed, pod: %v. Allowed values: %v", [input.review.object.metadata.name, input.parameters])
        }

        input_share_hostnetwork(o) {
            not input.parameters.hostNetwork
            o.spec.hostNetwork
        }

        input_share_hostnetwork(_) {
            hostPort := input_containers[_].ports[_].hostPort
            hostPort < input.parameters.min
        }

        input_share_hostnetwork(_) {
            hostPort := input_containers[_].ports[_].hostPort
            hostPort > input.parameters.max
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
            not is_exempt(c)
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
            not is_exempt(c)
        }

        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
            not is_exempt(c)
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 713ba07e-a37a-4250-b43f-7dd9026f15ff
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 713ba07e-a37a-4250-b43f-7dd9026f15ff
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls the ability of any container to enable privileged mode.
        Corresponds to the `privileged` field in a PodSecurityPolicy. For more information,
        see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged
      metadata.gatekeeper.sh/title: Privileged Container
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:23Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspprivilegedcontainer
    resourceVersion: "1746760553678463024"
    uid: 0e685974-07fe-4e01-b6cb-ac4754a58b30
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPPrivilegedContainer
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls the ability of any container to enable privileged
              mode. Corresponds to the `privileged` field in a PodSecurityPolicy.
              For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspprivileged

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            # spec.containers.privileged field is immutable.
            not is_update(input.review)

            c := input_containers[_]
            not is_exempt(c)
            c.securityContext.privileged
            msg := sprintf("Privileged container is not allowed: %v, securityContext: %v", [c.name, c.securityContext])
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 0e685974-07fe-4e01-b6cb-ac4754a58b30
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 0e685974-07fe-4e01-b6cb-ac4754a58b30
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls the allowed `procMount` types for the container. Corresponds
        to the `allowedProcMountTypes` field in a PodSecurityPolicy. For more information,
        see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowedprocmounttypes
      metadata.gatekeeper.sh/title: Proc Mount
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:13Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspprocmount
    resourceVersion: "1746760545242463019"
    uid: 6b5b1855-197d-43d3-ae8f-3866e1d55e12
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPProcMount
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls the allowed `procMount` types for the container.
              Corresponds to the `allowedProcMountTypes` field in a PodSecurityPolicy.
              For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowedprocmounttypes
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              procMount:
                description: Defines the strategy for the security exposure of certain
                  paths in `/proc` by the container runtime. Setting to `Default`
                  uses the runtime defaults, where `Unmasked` bypasses the default
                  behavior.
                enum:
                - Default
                - Unmasked
                type: string
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspprocmount

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            # spec.containers.securityContext.procMount field is immutable.
            not is_update(input.review)

            c := input_containers[_]
            not is_exempt(c)
            allowedProcMount := get_allowed_proc_mount(input)
            not input_proc_mount_type_allowed(allowedProcMount, c)
            msg := sprintf("ProcMount type is not allowed, container: %v. Allowed procMount types: %v", [c.name, allowedProcMount])
        }

        input_proc_mount_type_allowed(allowedProcMount, c) {
            allowedProcMount == "default"
            lower(c.securityContext.procMount) == "default"
        }
        input_proc_mount_type_allowed(allowedProcMount, _) {
            allowedProcMount == "unmasked"
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
            c.securityContext.procMount
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
            c.securityContext.procMount
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
            c.securityContext.procMount
        }

        get_allowed_proc_mount(arg) = out {
            not arg.parameters
            out = "default"
        }
        get_allowed_proc_mount(arg) = out {
            not arg.parameters.procMount
            out = "default"
        }
        get_allowed_proc_mount(arg) = out {
            arg.parameters.procMount
            not valid_proc_mount(arg.parameters.procMount)
            out = "default"
        }
        get_allowed_proc_mount(arg) = out {
            valid_proc_mount(arg.parameters.procMount)
            out = lower(arg.parameters.procMount)
        }

        valid_proc_mount(str) {
            lower(str) == "default"
        }
        valid_proc_mount(str) {
            lower(str) == "unmasked"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 6b5b1855-197d-43d3-ae8f-3866e1d55e12
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 6b5b1855-197d-43d3-ae8f-3866e1d55e12
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires the use of a read-only root file system by pod containers.
        Corresponds to the `readOnlyRootFilesystem` field in a PodSecurityPolicy.
        For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
      metadata.gatekeeper.sh/title: Read Only Root Filesystem
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:07Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspreadonlyrootfilesystem
    resourceVersion: "1746760516394527023"
    uid: d5f47536-f772-4c52-857b-0e6616a95ce4
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPReadOnlyRootFilesystem
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Requires the use of a read-only root file system by pod containers.
              Corresponds to the `readOnlyRootFilesystem` field in a PodSecurityPolicy.
              For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspreadonlyrootfilesystem

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            # spec.containers.readOnlyRootFilesystem field is immutable.
            not is_update(input.review)

            c := input_containers[_]
            not is_exempt(c)
            input_read_only_root_fs(c)
            msg := sprintf("only read-only root filesystem container is allowed: %v", [c.name])
        }

        input_read_only_root_fs(c) {
            not has_field(c, "securityContext")
        }
        input_read_only_root_fs(c) {
            not c.securityContext.readOnlyRootFilesystem == true
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: d5f47536-f772-4c52-857b-0e6616a95ce4
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: d5f47536-f772-4c52-857b-0e6616a95ce4
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Controls the seccomp profile used by containers. Corresponds to
        the `seccomp.security.alpha.kubernetes.io/allowedProfileNames` annotation
        on a PodSecurityPolicy. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
      metadata.gatekeeper.sh/title: Seccomp
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:19Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspseccomp
    resourceVersion: "1746760551783103006"
    uid: 36902550-7bb5-4499-97af-6f73623a6709
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPSeccomp
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Controls the seccomp profile used by containers. Corresponds
              to the `seccomp.security.alpha.kubernetes.io/allowedProfileNames` annotation
              on a PodSecurityPolicy. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
            properties:
              allowedLocalhostFiles:
                description: |-
                  When using securityContext naming scheme for seccomp and including `Localhost` this array holds the allowed profile JSON files.
                  Putting a `*` in this array will allows all JSON files to be used.
                  This field is required to allow `Localhost` in securityContext as with an empty list it will block.
                items:
                  type: string
                type: array
              allowedProfiles:
                description: |-
                  An array of allowed profile values for seccomp on Pods/Containers.
                  Can use the annotation naming scheme: `runtime/default`, `docker/default`, `unconfined` and/or `localhost/some-profile.json`. The item `localhost/*` will allow any localhost based profile.
                  Can also use the securityContext naming scheme: `RuntimeDefault`, `Unconfined` and/or `Localhost`. For securityContext `Localhost`, use the parameter `allowedLocalhostProfiles` to list the allowed profile JSON files.
                  The policy code will translate between the two schemes so it is not necessary to use both.
                  Putting a `*` in this array allows all Profiles to be used.
                  This field is required since with an empty list this policy will block all workloads.
                items:
                  type: string
                type: array
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspseccomp

        import data.lib.exempt_container.is_exempt

        container_annotation_key_prefix = "container.seccomp.security.alpha.kubernetes.io/"

        pod_annotation_key = "seccomp.security.alpha.kubernetes.io/pod"

        naming_translation = {
            # securityContext -> annotation
            "RuntimeDefault": ["runtime/default", "docker/default"],
            "Unconfined": ["unconfined"],
            "Localhost": ["localhost"],
            # annotation -> securityContext
            "runtime/default": ["RuntimeDefault"],
            "docker/default": ["RuntimeDefault"],
            "unconfined": ["Unconfined"],
            "localhost": ["Localhost"],
        }

        violation[{"msg": msg}] {
            not input_wildcard_allowed_profiles
            allowed_profiles := get_allowed_profiles
            container := input_containers[name]
            not is_exempt(container)
            result := get_profile(container)
            not allowed_profile(result.profile, result.file, allowed_profiles)
            msg := get_message(result.profile, result.file, name, result.location, allowed_profiles)
        }

        get_message(profile, _, name, location, allowed_profiles) = message {
            not profile == "Localhost"
            message := sprintf("Seccomp profile '%v' is not allowed for container '%v'. Found at: %v. Allowed profiles: %v", [profile, name, location, allowed_profiles])
        }

        get_message(profile, file, name, location, allowed_profiles) = message {
            profile == "Localhost"
            message := sprintf("Seccomp profile '%v' with file '%v' is not allowed for container '%v'. Found at: %v. Allowed profiles: %v", [profile, file, name, location, allowed_profiles])
        }

        input_wildcard_allowed_profiles {
            input.parameters.allowedProfiles[_] == "*"
        }

        input_wildcard_allowed_files {
            input.parameters.allowedLocalhostFiles[_] == "*"
        }

        input_wildcard_allowed_files {
            "localhost/*" == input.parameters.allowedProfiles[_]
        }

        # Simple allowed Profiles
        allowed_profile(profile, _, allowed) {
            not startswith(lower(profile), "localhost")
            profile == allowed[_]
        }

        # seccomp Localhost without wildcard
        allowed_profile(profile, file, allowed) {
            profile == "Localhost"
            not input_wildcard_allowed_files
            profile == allowed[_]
            allowed_files := {x | x := object.get(input.parameters, "allowedLocalhostFiles", [])[_]} | get_annotation_localhost_files
            file == allowed_files[_]
        }

        # seccomp Localhost with wildcard
        allowed_profile(profile, _, allowed) {
            profile == "Localhost"
            input_wildcard_allowed_files
            profile == allowed[_]
        }

        # annotation localhost with wildcard
        allowed_profile(profile, _, allowed) {
            "localhost/*" == allowed[_]
            startswith(profile, "localhost/")
        }

        # annotation localhost without wildcard
        allowed_profile(profile, _, allowed) {
            startswith(profile, "localhost/")
            profile == allowed[_]
        }

        # Localhost files from annotation scheme
        get_annotation_localhost_files[file] {
            profile := input.parameters.allowedProfiles[_]
            startswith(profile, "localhost/")
            file := replace(profile, "localhost/", "")
        }

        # The profiles explicitly in the list
        get_allowed_profiles[allowed] {
            allowed := input.parameters.allowedProfiles[_]
        }

        # The simply translated profiles
        get_allowed_profiles[allowed] {
            profile := input.parameters.allowedProfiles[_]
            not startswith(lower(profile), "localhost")
            allowed := naming_translation[profile][_]
        }

        # Seccomp Localhost to annotation translation
        get_allowed_profiles[allowed] {
            profile := input.parameters.allowedProfiles[_]
            profile == "Localhost"
            file := object.get(input.parameters, "allowedLocalhostFiles", [])[_]
            allowed := sprintf("%v/%v", [naming_translation[profile][_], file])
        }

        # Annotation localhost to Seccomp translation
        get_allowed_profiles[allowed] {
            profile := input.parameters.allowedProfiles[_]
            startswith(profile, "localhost")
            allowed := naming_translation.localhost[_]
        }

        # Container profile as defined in pod annotation
        get_profile(container) = {"profile": profile, "file": "", "location": location} {
            not has_securitycontext_container(container)
            not has_annotation(get_container_annotation_key(container.name))
            not has_securitycontext_pod
            profile := input.review.object.metadata.annotations[pod_annotation_key]
            location := sprintf("annotation %v", [pod_annotation_key])
        }

        # Container profile as defined in container annotation
        get_profile(container) = {"profile": profile, "file": "", "location": location} {
            not has_securitycontext_container(container)
            not has_securitycontext_pod
            container_annotation := get_container_annotation_key(container.name)
            has_annotation(container_annotation)
            profile := input.review.object.metadata.annotations[container_annotation]
            location := sprintf("annotation %v", [container_annotation])
        }

        # Container profile as defined in pods securityContext
        get_profile(container) = {"profile": profile, "file": file, "location": location} {
            not has_securitycontext_container(container)
            profile := input.review.object.spec.securityContext.seccompProfile.type
            file := object.get(input.review.object.spec.securityContext.seccompProfile, "localhostProfile", "")
            location := "pod securityContext"
        }

        # Container profile as defined in containers securityContext
        get_profile(container) = {"profile": profile, "file": file, "location": location} {
            has_securitycontext_container(container)
            profile := container.securityContext.seccompProfile.type
            file := object.get(container.securityContext.seccompProfile, "localhostProfile", "")
            location := "container securityContext"
        }

        # Container profile missing
        get_profile(container) = {"profile": "not configured", "file": "", "location": "no explicit profile found"} {
            not has_annotation(get_container_annotation_key(container.name))
            not has_annotation(pod_annotation_key)
            not has_securitycontext_pod
            not has_securitycontext_container(container)
        }

        has_annotation(annotation) {
            input.review.object.metadata.annotations[annotation]
        }

        has_securitycontext_pod {
            input.review.object.spec.securityContext.seccompProfile
        }

        has_securitycontext_container(container) {
            container.securityContext.seccompProfile
        }

        get_container_annotation_key(name) = annotation {
            annotation := concat("", [container_annotation_key_prefix, name])
        }

        input_containers[container.name] = container {
            container := input.review.object.spec.containers[_]
        }

        input_containers[container.name] = container {
            container := input.review.object.spec.initContainers[_]
        }

        input_containers[container.name] = container {
            container := input.review.object.spec.ephemeralContainers[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 36902550-7bb5-4499-97af-6f73623a6709
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 36902550-7bb5-4499-97af-6f73623a6709
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Defines an allow-list of seLinuxOptions configurations for pod
        containers. Corresponds to a PodSecurityPolicy requiring SELinux configs.
        For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux
      metadata.gatekeeper.sh/title: SELinux V2
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:18Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspselinuxv2
    resourceVersion: "1746760551519951019"
    uid: e407abfe-aae2-4b63-974e-63d8796c3c97
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPSELinuxV2
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Defines an allow-list of seLinuxOptions configurations for
              pod containers. Corresponds to a PodSecurityPolicy requiring SELinux
              configs. For more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux
            properties:
              allowedSELinuxOptions:
                description: An allow-list of SELinux options configurations.
                items:
                  description: An allowed configuration of SELinux options for a pod
                    container.
                  properties:
                    level:
                      description: An SELinux level.
                      type: string
                    role:
                      description: An SELinux role.
                      type: string
                    type:
                      description: An SELinux type.
                      type: string
                    user:
                      description: An SELinux user.
                      type: string
                  type: object
                type: array
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8spspselinux

        import data.lib.exclude_update.is_update
        import data.lib.exempt_container.is_exempt

        # Disallow top level custom SELinux options
        violation[{"msg": msg, "details": {}}] {
            # spec.securityContext.seLinuxOptions field is immutable.
            not is_update(input.review)

            has_field(input.review.object.spec.securityContext, "seLinuxOptions")
            not input_seLinuxOptions_allowed(input.review.object.spec.securityContext.seLinuxOptions)
            msg := sprintf("SELinux options is not allowed, pod: %v. Allowed options: %v", [input.review.object.metadata.name, input.parameters.allowedSELinuxOptions])
        }
        # Disallow container level custom SELinux options
        violation[{"msg": msg, "details": {}}] {
            # spec.containers.securityContext.seLinuxOptions field is immutable.
            not is_update(input.review)

            c := input_security_context[_]
            not is_exempt(c)
            has_field(c.securityContext, "seLinuxOptions")
            not input_seLinuxOptions_allowed(c.securityContext.seLinuxOptions)
            msg := sprintf("SELinux options is not allowed, pod: %v, container: %v. Allowed options: %v", [input.review.object.metadata.name, c.name, input.parameters.allowedSELinuxOptions])
        }

        input_seLinuxOptions_allowed(options) {
            params := input.parameters.allowedSELinuxOptions[_]
            field_allowed("level", options, params)
            field_allowed("role", options, params)
            field_allowed("type", options, params)
            field_allowed("user", options, params)
        }

        field_allowed(field, options, params) {
            params[field] == options[field]
        }
        field_allowed(field, options, _) {
            not has_field(options, field)
        }

        input_security_context[c] {
            c := input.review.object.spec.containers[_]
            has_field(c.securityContext, "seLinuxOptions")
        }
        input_security_context[c] {
            c := input.review.object.spec.initContainers[_]
            has_field(c.securityContext, "seLinuxOptions")
        }
        input_security_context[c] {
            c := input.review.object.spec.ephemeralContainers[_]
            has_field(c.securityContext, "seLinuxOptions")
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: e407abfe-aae2-4b63-974e-63d8796c3c97
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: e407abfe-aae2-4b63-974e-63d8796c3c97
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts mountable volume types to those specified by the user.
        Corresponds to the `volumes` field in a PodSecurityPolicy. For more information,
        see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
      metadata.gatekeeper.sh/title: Volume Types
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:12Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspvolumetypes
    resourceVersion: "1746760542459951015"
    uid: ae8a8de2-c78b-4368-b3ce-9674c3caaa56
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPVolumeTypes
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Restricts mountable volume types to those specified by the
              user. Corresponds to the `volumes` field in a PodSecurityPolicy. For
              more information, see https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
            properties:
              volumes:
                description: '`volumes` is an array of volume types. All volume types
                  can be enabled using `*`.'
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8spspvolumetypes

        import data.lib.exclude_update.is_update

        violation[{"msg": msg, "details": {}}] {
            # spec.volumes field is immutable.
            not is_update(input.review)

            volume_fields := {x | input.review.object.spec.volumes[_][x]; x != "name"}
            field := volume_fields[_]
            not input_volume_type_allowed(field)
            msg := sprintf("The volume type %v is not allowed, pod: %v. Allowed volume types: %v", [field, input.review.object.metadata.name, input.parameters.volumes])
        }

        # * may be used to allow all volume types
        input_volume_type_allowed(_) {
            input.parameters.volumes[_] == "*"
        }

        input_volume_type_allowed(field) {
            field == input.parameters.volumes[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: ae8a8de2-c78b-4368-b3ce-9674c3caaa56
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: ae8a8de2-c78b-4368-b3ce-9674c3caaa56
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts running of Windows HostProcess containers / pods. See
        https://kubernetes.io/docs/tasks/configure-pod-container/create-hostprocess-pod/
        for more information.
      metadata.gatekeeper.sh/title: Restricts Windows HostProcess containers / pods.
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:12Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spspwindowshostprocess
    resourceVersion: "1746760542033855016"
    uid: d4bc04c8-cb87-4702-82be-0b106a57a24f
  spec:
    crd:
      spec:
        names:
          kind: K8sPSPWindowsHostProcess
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8spspwindowshostprocess

        violation[{"msg": msg}] {
          c := input_containers[_]
          is_hostprocess(c)
          msg := sprintf("Windows HostProcess container is not allowed: %v", [c.name])
        }

        # returns true if hostProcess is set to true for container
        is_hostprocess(c) {
          c.securityContext.windowsOptions.hostProcess == true
        }

        # returns true if hostProcess is not specified for container AND is set to true on pod
        is_hostprocess(c) {
          not sets_hostprocess(c)
          input.review.object.spec.securityContext.windowsOptions.hostProcess == true
        }

        # returns true if hostProcess is set for container
        sets_hostprocess(c) {
          c.securityContext.windowsOptions.hostProcess != null
        }

        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
          c := input.review.object.spec.initContainers[_]
        }

        input_containers[c] {
          c := input.review.object.spec.ephemeralContainers[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: d4bc04c8-cb87-4702-82be-0b106a57a24f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: d4bc04c8-cb87-4702-82be-0b106a57a24f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires containers run as non-root users. For more information,
        see https://kubernetes.io/docs/concepts/security/pod-security-standards/
      metadata.gatekeeper.sh/title: Requires containers run as non-root users.
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:23Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8spssrunasnonroot
    resourceVersion: "1746760553573391003"
    uid: c2efebef-62fa-436f-8a49-89d6f93f7e9b
  spec:
    crd:
      spec:
        names:
          kind: K8sPSSRunAsNonRoot
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8spssrunasnonroot

        # Require Pod set spec.securityContext.runAsNonRoot == true
        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          object.get(input.review.object, ["spec", "securityContext", "runAsNonRoot"], null) != true
          msg := sprintf("Pods are required to run as non-root users: %v", [input.review.object.metadata.name])
        }

        # Require Container .securityContext.runAsNonRoot == true or null if Pod pec.securityContext.runAsNonRoot == true
        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          c := input_containers[_]
          not_runasnonroot(c)
          msg := sprintf("Containers are required to run as non-root users: %v", [c.name])
        }

        # returns true if runAsNonRoot is false for container
        not_runasnonroot(c) {
          c.securityContext.runAsNonRoot == false
        }

        # returns true if runAsNonRoot is not specified for container AND is not set to true on pod
        not_runasnonroot(c) {
          object.get(c, ["securityContext", "runAsNonRoot"], null) == null
          object.get(input.review.object, ["spec", "securityContext", "runAsNonRoot"], null) != true
        }

        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
          c := input.review.object.spec.initContainers[_]
        }

        input_containers[c] {
          c := input.review.object.spec.ephemeralContainers[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: c2efebef-62fa-436f-8a49-89d6f93f7e9b
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: c2efebef-62fa-436f-8a49-89d6f93f7e9b
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires that objects with the field `spec.replicas` (Deployments,
        ReplicaSets, etc.) specify a number of replicas within defined ranges.
      metadata.gatekeeper.sh/title: Replica Limits
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:18Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8sreplicalimits
    resourceVersion: "1746760551338575008"
    uid: 5e617309-bf27-4ba8-b289-fcc18b6ef3ad
  spec:
    crd:
      spec:
        names:
          kind: K8sReplicaLimits
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              ranges:
                description: Allowed ranges for numbers of replicas.  Values are inclusive.
                items:
                  description: A range of allowed replicas.  Values are inclusive.
                  properties:
                    max_replicas:
                      description: The maximum number of replicas allowed, inclusive.
                      type: integer
                    min_replicas:
                      description: The minimum number of replicas allowed, inclusive.
                      type: integer
                  type: object
                type: array
            type: object
    targets:
    - rego: |
        package k8sreplicalimits

        object_name = input.review.object.metadata.name
        object_kind = input.review.kind.kind

        violation[{"msg": msg}] {
            spec := input.review.object.spec
            not input_replica_limit(spec)
            msg := sprintf("The provided number of replicas is not allowed for %v: %v. Allowed ranges: %v", [object_kind, object_name, input.parameters])
        }

        input_replica_limit(spec) {
            provided := spec.replicas
            count(input.parameters.ranges) > 0
            range := input.parameters.ranges[_]
            value_within_range(range, provided)
        }

        value_within_range(range, value) {
            range.min_replicas <= value
            range.max_replicas >= value
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 5e617309-bf27-4ba8-b289-fcc18b6ef3ad
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 5e617309-bf27-4ba8-b289-fcc18b6ef3ad
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires either Pod Security Admission or an external policy control
        system
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["admissionregistration.k8s.io"],
              "versions": ["v1", "v1beta1"],
              "kinds": ["ValidatingWebhookConfiguration"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Require Admission Controller
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:06Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8srequireadmissioncontroller
    resourceVersion: "1746760514919631005"
    uid: 07d523c8-5f4a-432a-a9ef-502ed8dde973
  spec:
    crd:
      spec:
        names:
          kind: K8sRequireAdmissionController
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              permittedValidatingWebhooks:
                description: List of permitted validating webhooks which are valid
                  external policy control systems
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8srequireadmissioncontroller

        violation[{"msg": msg}] {
          input.review.kind.kind == "Namespace"
          permittedValidatingWebhooks := object.get(input, ["parameters", "permittedValidatingWebhooks"], {})

          # Check neither the default admission control or a permitted Validating Webhook is present
          not has_permitted_admission_controller(input.review.object, permittedValidatingWebhooks)

          msg := sprintf("Namespace <%v> has neither the Pod Security Admission, nor is a permitted <%v> external admission controller present", [input.review.object.metadata.name, permittedValidatingWebhooks])
        }

        has_permitted_admission_controller(obj, _) {
          providedLabels := {label | obj.metadata.labels[label]}
          startswith(providedLabels[_], "pod-security.kubernetes.io/")
        }

        has_permitted_admission_controller(_, permittedValidatingWebhooks) {
          permittedValidatingWebhooks[_] == data.inventory.cluster["admissionregistration.k8s.io/v1"].ValidatingWebhookConfiguration[_].metadata.name
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 07d523c8-5f4a-432a-a9ef-502ed8dde973
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 07d523c8-5f4a-432a-a9ef-502ed8dde973
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires the Binary Authorization Validating Admission Webhook.
        Constraints using this `ConstraintTemplate` will be audit only regardless
        of `enforcementAction` value.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["admissionregistration.k8s.io"],
              "versions": ["v1", "v1beta1"],
              "kinds": ["ValidatingWebhookConfiguration"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Requires Binary Authorization
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8srequirebinauthz
    resourceVersion: "1746760523672255004"
    uid: 8793c5e1-5dab-4c65-b813-04add86bc8ce
  spec:
    crd:
      spec:
        names:
          kind: K8sRequireBinAuthZ
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8srequirebinauthz

        violation[{"msg": msg}] {
          # Use the default namespace for violation uniqueness as it can't be deleted
          input.review.kind.kind == "Namespace"
          input.review.object.metadata.name == "default"

          # Audit Only
          input.review.operation != "UPDATE"
          input.review.operation != "CREATE"

          not data.inventory.cluster["admissionregistration.k8s.io/v1"].ValidatingWebhookConfiguration["binauthz-admission-controller"]
          msg := "Cluster does not have the required BinAuthz Validating Admission Webhook"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8793c5e1-5dab-4c65-b813-04add86bc8ce
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8793c5e1-5dab-4c65-b813-04add86bc8ce
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforces the use of Container-Optimized OS from Google on Nodes.
      metadata.gatekeeper.sh/title: Require COS Node Image
      metadata.gatekeeper.sh/version: 1.1.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:19Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srequirecosnodeimage
    resourceVersion: "1746760552077007004"
    uid: fb3a7bd1-2ec9-438c-bb5b-fcfbc1d7c3cd
  spec:
    crd:
      spec:
        names:
          kind: K8sRequireCosNodeImage
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptOsImages:
                description: A list of exempt OS Images.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8srequirecosnodeimage

        violation[{"msg": msg}] {
          input.review.kind.kind == "Node"
          node_name := input.review.object.metadata.name
          not is_exempt_image(input.review.object)
          does_not_have_cos_image(input.review.object)
          msg := sprintf("Node <%v> has an OS Image other than Container-Optimized OS from Google", [node_name])
        }

        does_not_have_cos_image(node_object) {
          node_object.status.nodeInfo.osImage != "Container-Optimized OS from Google"
        }

        does_not_have_cos_image(node_object) {
          not node_object.status.nodeInfo.osImage
        }

        is_exempt_image(node_object) {
          exempt_image := input.parameters.exemptOsImages[_]
          not endswith(exempt_image, "*")
          node_object.status.nodeInfo.osImage == exempt_image
        }

        is_exempt_image(node_object) {
          exempt_image := input.parameters.exemptOsImages[_]
          endswith(exempt_image, "*")
          startswith(node_object.status.nodeInfo.osImage, trim_suffix(exempt_image, "*"))
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: fb3a7bd1-2ec9-438c-bb5b-fcfbc1d7c3cd
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: fb3a7bd1-2ec9-438c-bb5b-fcfbc1d7c3cd
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires the list of daemonsets specified to be present.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["extensions"],
              "versions": ["v1beta1"],
              "kinds": ["DaemonSet"]
            },
            {
              "groups": ["apps"],
              "versions": ["v1beta2", "v1"],
              "kinds": ["DaemonSet"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Required Daemonsets
      metadata.gatekeeper.sh/version: 1.1.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:15Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8srequiredaemonsets
    resourceVersion: "1746760549772415024"
    uid: 26eabd19-abb0-4762-b935-d6b603b7f096
  spec:
    crd:
      spec:
        names:
          kind: K8sRequireDaemonsets
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              requiredDaemonsets:
                description: A list of names and namespaces of the required daemonsets.
                items:
                  properties:
                    name:
                      description: The name of the required daemonset.
                      type: string
                    namespace:
                      description: The namespace for the required daemonset.
                      type: string
                  type: object
                type: array
              restrictNodeSelector:
                default: false
                description: The daemonsets cannot include `NodeSelector`.
                type: boolean
            type: object
    targets:
    - rego: |
        package k8srequiredaemonsets

        violation[{"msg": msg}] {
          input.review.kind.kind == "Namespace"
          daemonsets := object.get(input.parameters, "requiredDaemonsets", [])
          required := daemonsets[_]
          input.review.object.metadata.name == required.namespace
          not found_daemonset(required, data.inventory)
          msg := sprintf("Namespace <%v> does not have a required daemonset <%v>", [required.namespace, required.name])
        }

        found_daemonset(required, inventory) {
          object.get(input, ["parameters", "restrictNodeSelector"], null) != true
          inventory.namespace[required.namespace][_].DaemonSet[required.name]
        }

        found_daemonset(required, inventory) {
          object.get(input, ["parameters", "restrictNodeSelector"], null) == true
          inventory.namespace[required.namespace][_].DaemonSet[required.name]
          not found_nodeselector(required, inventory)
        }

        found_nodeselector(required, inventory) {
          inventory.namespace[required.namespace][_].DaemonSet[required.name].spec.template.spec.nodeSelector
        }

        # Raise a violation if the namespace of the required daemonset doesn't exist
        violation[{"msg": msg}] {
          input.review.kind.kind == "Namespace"
          daemonsets := object.get(input.parameters, "requiredDaemonsets", [])

          # We use the default namespace for violation uniqueness as it can't be deleted
          input.review.object.metadata.name == "default"
          required := daemonsets[_]
          not found_namespace(required.namespace, data.inventory)
          msg := sprintf("Namespace <%v> for required daemonset <%v> does not exist", [required.namespace, required.name])
        }

        found_namespace(namespace, inventory) {
          inventory.namespace[namespace]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 26eabd19-abb0-4762-b935-d6b603b7f096
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 26eabd19-abb0-4762-b935-d6b603b7f096
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires resources to contain specified annotations, with values
        matching provided regular expressions.
      metadata.gatekeeper.sh/title: Required Annotations
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:21Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srequiredannotations
    resourceVersion: "1746760552754015012"
    uid: c1800647-34b3-4ac7-b586-8aaeca123d02
  spec:
    crd:
      spec:
        names:
          kind: K8sRequiredAnnotations
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              annotations:
                description: A list of annotations and values the object must specify.
                items:
                  properties:
                    allowedRegex:
                      description: If specified, a regular expression the annotation's
                        value must match. The value must contain at least one match
                        for the regular expression.
                      type: string
                    key:
                      description: The required annotation.
                      type: string
                  type: object
                type: array
              message:
                type: string
            type: object
    targets:
    - rego: |
        package k8srequiredannotations

        violation[{"msg": msg, "details": {"missing_annotations": missing}}] {
            provided := {annotation | input.review.object.metadata.annotations[annotation]}
            required := {annotation | annotation := input.parameters.annotations[_].key}
            missing := required - provided
            count(missing) > 0
            msg := sprintf("you must provide annotation(s): %v", [missing])
        }

        violation[{"msg": msg}] {
          value := input.review.object.metadata.annotations[key]
          expected := input.parameters.annotations[_]
          expected.key == key
          expected.allowedRegex != ""
          not regex.match(expected.allowedRegex, value)
          msg := sprintf("Annotation <%v: %v> does not satisfy allowed regex: %v", [key, value, expected.allowedRegex])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: c1800647-34b3-4ac7-b586-8aaeca123d02
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: c1800647-34b3-4ac7-b586-8aaeca123d02
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires that every namespace defined in the cluster has a default
        deny NetworkPolicy for egress.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["extensions"],
              "versions": ["v1beta1"],
              "kinds": ["NetworkPolicy"]
            },
            {
              "groups": ["networking.k8s.io"],
              "versions": ["v1"],
              "kinds": ["NetworkPolicy"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Require Default Deny Egress Policy
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:14Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8srequiredefaultdenyegresspolicy
    resourceVersion: "1746760548290031023"
    uid: 4dc8ee8d-67ae-4047-9a90-5a4dbb0f390f
  spec:
    crd:
      spec:
        names:
          kind: K8sRequireDefaultDenyEgressPolicy
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8srequiredefaultdenyegresspolicy

        violation[{"msg": msg}] {
          input.review.kind.kind == "Namespace"
          not found_default_deny_egress_networkpolicy(input.review.object.metadata.name)
          msg := sprintf("Namespace <%v> does not have a default deny NetworkPolicy for egress", [input.review.object.metadata.name])
        }

        found_default_deny_egress_networkpolicy(ns) {
          np := data.inventory.namespace[ns][_].NetworkPolicy[_]
          np.spec.podSelector == {}
          np.spec.policyTypes[_] = "Egress"
          not_exists_egress_rules(np) #No egress rules
        }

        not_exists_egress_rules(val) {
          not val.spec.egress
        }

        not_exists_egress_rules(val) {
          count(val.spec.egress) == 0
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 4dc8ee8d-67ae-4047-9a90-5a4dbb0f390f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 4dc8ee8d-67ae-4047-9a90-5a4dbb0f390f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires resources to contain specified labels, with values matching
        provided regular expressions.
      metadata.gatekeeper.sh/title: Required Labels
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:14Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srequiredlabels
    resourceVersion: "1746760547363791018"
    uid: d29d9085-6336-4eff-bd1d-4471b98cc6df
  spec:
    crd:
      spec:
        names:
          kind: K8sRequiredLabels
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              labels:
                description: A list of labels and values the object must specify.
                items:
                  properties:
                    allowedRegex:
                      description: If specified, a regular expression the annotation's
                        value must match. The value must contain at least one match
                        for the regular expression.
                      type: string
                    key:
                      description: The required label.
                      type: string
                  type: object
                type: array
              message:
                type: string
            type: object
    targets:
    - rego: |
        package k8srequiredlabels

        get_message(parameters, _default) := _default {
          not parameters.message
        }

        get_message(parameters, _) := parameters.message

        violation[{"msg": msg, "details": {"missing_labels": missing}}] {
          provided := {label | input.review.object.metadata.labels[label]}
          required := {label | label := input.parameters.labels[_].key}
          missing := required - provided
          count(missing) > 0
          def_msg := sprintf("you must provide labels: %v", [missing])
          msg := get_message(input.parameters, def_msg)
        }

        violation[{"msg": msg}] {
          value := input.review.object.metadata.labels[key]
          expected := input.parameters.labels[_]
          expected.key == key
          # do not match if allowedRegex is not defined, or is an empty string
          expected.allowedRegex != ""
          not regex.match(expected.allowedRegex, value)
          def_msg := sprintf("Label <%v: %v> does not satisfy allowed regex: %v", [key, value, expected.allowedRegex])
          msg := get_message(input.parameters, def_msg)
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: d29d9085-6336-4eff-bd1d-4471b98cc6df
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: d29d9085-6336-4eff-bd1d-4471b98cc6df
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires Pods to have readiness and/or liveness probes.
      metadata.gatekeeper.sh/title: Required Probes
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:12Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srequiredprobes
    resourceVersion: "1746760543035903007"
    uid: 44aa324c-f32c-4aa5-9f14-7b4a24839250
  spec:
    crd:
      spec:
        names:
          kind: K8sRequiredProbes
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              probeTypes:
                description: The probe must define a field listed in `probeType` in
                  order to satisfy the constraint (ex. `tcpSocket` satisfies `['tcpSocket',
                  'exec']`)
                items:
                  type: string
                type: array
              probes:
                description: 'A list of probes that are required (ex: `readinessProbe`)'
                items:
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exclude_update

        is_update(review) {
            review.operation == "UPDATE"
        }
      rego: |
        package k8srequiredprobes

        import data.lib.exclude_update.is_update

        probe_type_set = probe_types {
            probe_types := {type | type := input.parameters.probeTypes[_]}
        }

        violation[{"msg": msg}] {
            # Probe fields are immutable.
            not is_update(input.review)

            container := input.review.object.spec.containers[_]
            probe := input.parameters.probes[_]
            probe_is_missing(container, probe)
            msg := get_violation_message(container, input.review, probe)
        }

        probe_is_missing(ctr, probe) = true {
            not ctr[probe]
        }

        probe_is_missing(ctr, probe) = true {
            probe_field_empty(ctr, probe)
        }

        probe_field_empty(ctr, probe) = true {
            probe_fields := {field | ctr[probe][field]}
            diff_fields := probe_type_set - probe_fields
            count(diff_fields) == count(probe_type_set)
        }

        get_violation_message(container, review, probe) = msg {
            msg := sprintf("Container <%v> in your <%v> <%v> has no <%v>", [container.name, review.kind.kind, review.object.metadata.name, probe])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 44aa324c-f32c-4aa5-9f14-7b4a24839250
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 44aa324c-f32c-4aa5-9f14-7b4a24839250
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires containers to have defined resources set.
        https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
      metadata.gatekeeper.sh/title: Required Resources
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:07Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srequiredresources
    resourceVersion: "1746760517909327018"
    uid: 18b214b6-701d-4a9c-a1ad-77d8456b8e3d
  spec:
    crd:
      spec:
        names:
          kind: K8sRequiredResources
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exemptImages:
                description: |-
                  Any container that uses an image that matches an entry in this list will be excluded from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.
                  It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name) in order to avoid unexpectedly exempting images from an untrusted repository.
                items:
                  type: string
                type: array
              limits:
                description: A list of limits that should be enforced (`cpu`, `memory`,
                  or both).
                items:
                  enum:
                  - cpu
                  - memory
                  type: string
                type: array
              requests:
                description: A list of requests that should be enforced (`cpu`, `memory`,
                  or both).
                items:
                  enum:
                  - cpu
                  - memory
                  type: string
                type: array
            type: object
    targets:
    - libs:
      - |
        package lib.exempt_container

        is_exempt(container) {
            exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
            img := container.image
            exemption := exempt_images[_]
            _matches_exemption(img, exemption)
        }

        _matches_exemption(img, exemption) {
            not endswith(exemption, "*")
            exemption == img
        }

        _matches_exemption(img, exemption) {
            endswith(exemption, "*")
            prefix := trim_suffix(exemption, "*")
            startswith(img, prefix)
        }
      rego: |
        package k8srequiredresources

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "containers"}]
        }

        violation[{"msg": msg}] {
          general_violation[{"msg": msg, "field": "initContainers"}]
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          provided := {resource_type | container.resources.limits[resource_type]}
          required := {resource_type | resource_type := input.parameters.limits[_]}
          missing := required - provided
          count(missing) > 0
          msg := sprintf("container <%v> does not have <%v> limits defined", [container.name, missing])
        }

        general_violation[{"msg": msg, "field": field}] {
          container := input.review.object.spec[field][_]
          not is_exempt(container)
          provided := {resource_type | container.resources.requests[resource_type]}
          required := {resource_type | resource_type := input.parameters.requests[_]}
          missing := required - provided
          count(missing) > 0
          msg := sprintf("container <%v> does not have <%v> requests defined", [container.name, missing])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 18b214b6-701d-4a9c-a1ad-77d8456b8e3d
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 18b214b6-701d-4a9c-a1ad-77d8456b8e3d
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires that every namespace defined in the cluster has a NetworkPolicy.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["extensions"],
              "versions": ["v1beta1"],
              "kinds": ["NetworkPolicy"]
            },
            {
              "groups": ["networking.k8s.io"],
              "versions": ["v1"],
              "kinds": ["NetworkPolicy"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Require Namespace Network Policies
      metadata.gatekeeper.sh/version: 1.0.6
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:05Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8srequirenamespacenetworkpolicies
    resourceVersion: "1746760506706863014"
    uid: b9e632dc-cb52-44bd-b603-247a2f537a20
  spec:
    crd:
      spec:
        names:
          kind: K8sRequireNamespaceNetworkPolicies
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8srequirenamespacenetworkpolicies

        violation[{"msg": msg}] {
          input.review.kind.kind == "Namespace"
          input.review.operation != "CREATE"
          not namespace_has_networkpolicy(input.review.object.metadata.name, data.inventory)
          msg := sprintf("Namespace <%v> does not have a NetworkPolicy", [input.review.object.metadata.name])
        }

        namespace_has_networkpolicy(ns, inventory) {
          inventory.namespace[ns][_].NetworkPolicy[_]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b9e632dc-cb52-44bd-b603-247a2f537a20
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b9e632dc-cb52-44bd-b603-247a2f537a20
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Enforces which CIDR blocks are allowed for network ingress and
        egress.
      metadata.gatekeeper.sh/title: Require Valid Ranges for Networks
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:11Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srequirevalidrangesfornetworks
    resourceVersion: "1746760537432543018"
    uid: 9c1bbdd4-cb38-466b-ba92-1b67aa5533b9
  spec:
    crd:
      spec:
        names:
          kind: K8sRequireValidRangesForNetworks
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedEgress:
                description: IP ranges in CIDR format (0.0.0.0/32) that are allowed
                  for egress.
                items:
                  type: string
                type: array
              allowedIngress:
                description: IP ranges in CIDR format (0.0.0.0/32) that are allowed
                  for ingress.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8srequirevalidrangesfornetworks

        violation[{"msg": msg, "details": {"deniedIngressIPRanges": forbiddenIngressCidr}}] {
          input.review.kind.kind == "NetworkPolicy"
          ingress_cidr := {cidr | cidr = input.review.object.spec.ingress[_].from[_].ipBlock.cidr}
          allowedIngress := {cidr | cidr := input.parameters.allowedIngress[_]}
          matches := net.cidr_contains_matches(allowedIngress, ingress_cidr)
          permittedMatches := {match | match := matches[_][1]}
          forbiddenIngressCidr = ingress_cidr - permittedMatches
          count(forbiddenIngressCidr) > 0

          msg := sprintf("%v has ingress IP outside the valid ingress range: %v", [input.review.kind.kind, forbiddenIngressCidr])
        }

        violation[{"msg": msg, "details": {"deniedEgressIPRanges": forbiddenEgressCidr}}] {
          input.review.kind.kind == "NetworkPolicy"
          egress_cidr := {cidr | cidr = input.review.object.spec.egress[_].from[_].ipBlock.cidr}
          allowedEgress := {cidr | cidr := input.parameters.allowedEgress[_]}
          matches := net.cidr_contains_matches(allowedEgress, egress_cidr)
          permittedMatches := {match | match := matches[_][1]}
          forbiddenEgressCidr = egress_cidr - permittedMatches
          count(forbiddenEgressCidr) > 0

          msg := sprintf("%v has egress IP outside the valid egress range: %v", [input.review.kind.kind, forbiddenEgressCidr])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 9c1bbdd4-cb38-466b-ba92-1b67aa5533b9
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 9c1bbdd4-cb38-466b-ba92-1b67aa5533b9
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restrict dynamic admission controllers to permitted ones
      metadata.gatekeeper.sh/title: Restrict Admission Controller
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:17Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictadmissioncontroller
    resourceVersion: "1746760551044671004"
    uid: b9f222b9-adfa-401b-abb6-66b2f503f7e8
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictAdmissionController
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              permittedMutatingWebhooks:
                description: List of permitted mutating webhooks (mutating admission
                  controllers)
                items:
                  type: string
                type: array
              permittedValidatingWebhooks:
                description: List of permitted validating webhooks (validating admission
                  controllers)
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8srestrictadmissioncontroller

        import future.keywords.in

        # Check mutating webhooks
        violation[{"msg": msg}] {
          input.review.kind.kind == "MutatingWebhookConfiguration"

          permittedWebhooks := object.get(input, ["parameters", "permittedMutatingWebhooks"], {})
          permittedWebhooksSet := {x | x = permittedWebhooks[_]}

          not input.review.object.metadata.name in permittedWebhooksSet

          msg := sprintf("Mutating webhook '<%v>' is not permitted. Permitted mutating webhooks: <%v>", [input.review.object.metadata.name, permittedWebhooksSet])
        }

        # Check validating webhooks
        violation[{"msg": msg}] {
          input.review.kind.kind == "ValidatingWebhookConfiguration"

          permittedWebhooks := object.get(input, ["parameters", "permittedValidatingWebhooks"], {})
          permittedWebhooksSet := {x | x = permittedWebhooks[_]}

          not input.review.object.metadata.name in permittedWebhooksSet

          msg := sprintf("Validating webhook '<%v>' is not permitted. Permitted validating webhooks: <%v>", [input.review.object.metadata.name, permittedWebhooksSet])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b9f222b9-adfa-401b-abb6-66b2f503f7e8
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b9f222b9-adfa-401b-abb6-66b2f503f7e8
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts the use of service accounts tokens.
      metadata.gatekeeper.sh/title: Restrict Service Account Tokens
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:08Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictautomountserviceaccounttokens
    resourceVersion: "1746760517820495020"
    uid: b8f93447-34ed-4185-99bf-a22fbcee7d71
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictAutomountServiceAccountTokens
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8srestrictautomountserviceaccounttokens

        violation[{"msg": msg}] {
          input.review.kind.kind == "ServiceAccount"
          object.get(input.review.object, "automountServiceAccountToken", null) == true
          msg := "automountServiceAccountToken cannot be true"
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          object.get(object.get(input.review.object, "spec", {}), "automountServiceAccountToken", null) == true
          msg := "automountServiceAccountToken cannot be true"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: b8f93447-34ed-4185-99bf-a22fbcee7d71
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: b8f93447-34ed-4185-99bf-a22fbcee7d71
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows resources from containing specified labels unless there
        is an exception for the specific resource.
      metadata.gatekeeper.sh/title: Restrict Labels
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:05Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictlabels
    resourceVersion: "1746760507192591024"
    uid: fe9e905b-f1c5-40b7-a163-dc9abf51a29d
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictLabels
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              exceptions:
                description: Objects listed here are exempt from enforcement of this
                  constraint. All fields must be provided.
                items:
                  description: A single object's identification, based on group, kind,
                    namespace, and name.
                  properties:
                    group:
                      description: The Kubernetes group of the exempt object.
                      type: string
                    kind:
                      description: The Kubernetes kind of the exempt object.
                      type: string
                    name:
                      description: The name of the exempt object.
                      type: string
                    namespace:
                      description: The namespace of the exempt object. For cluster-scoped
                        resources, use the empty string `""`.
                      type: string
                  type: object
                type: array
              restrictedLabels:
                description: A list of label keys strings.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8srestrictlabels

        violation[{"msg": msg}] {
          some label
          input.review.object.metadata.labels[label]
          restrictedLabel := input.parameters.restrictedLabels[_]
          label == restrictedLabel
          not is_exception(input.parameters, input.review)
          msg := sprintf("<%v> label is restricted", [label])
        }

        is_exception(parameters, review) {
          exception := parameters.exceptions[_]
          review.kind.group == exception.group
          review.kind.kind == exception.kind
          review.object.metadata.namespace == exception.namespace
          review.object.metadata.name == exception.name
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: fe9e905b-f1c5-40b7-a163-dc9abf51a29d
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: fe9e905b-f1c5-40b7-a163-dc9abf51a29d
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts resources from using namespaces listed under the restrictedNamespaces
        parameter.
      metadata.gatekeeper.sh/title: Restrict Namespaces
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:15Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictnamespaces
    resourceVersion: "1746760549399279008"
    uid: 8e0f1626-6b3c-4e58-96c8-1487e46d0c5f
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictNamespaces
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              restrictedNamespaces:
                description: A list of Namespaces to restrict.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8srestrictnamespaces

        violation[{"msg": msg}] {
          restricted_ns := input.parameters.restrictedNamespaces[_]
          input.review.object.metadata.namespace == restricted_ns
          msg := sprintf("<%v> namespace is restricted", [restricted_ns])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8e0f1626-6b3c-4e58-96c8-1487e46d0c5f
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8e0f1626-6b3c-4e58-96c8-1487e46d0c5f
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Disallows resources from containing NFS URLS unless specified.
      metadata.gatekeeper.sh/title: Restrict NFS URLs
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:24Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictnfsurls
    resourceVersion: "1746760553884159024"
    uid: d1130417-383a-4994-a96f-1fe73c8c69f5
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictNfsUrls
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedNfsUrls:
                description: A list of allowed NFS URLs
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package k8srestrictnfsurls

        violation[{"msg": msg}] {
          input.review.kind.kind = "Pod"
          configuredUrls := input.review.object.spec.volumes[_]
          configuredUrl := sprintf("%v%v", [configuredUrls.nfs.server, configuredUrls.nfs.path])
          not is_allowed(configuredUrl)
          msg := sprintf("<%v> NFS URL is restricted", [configuredUrl])
        }

        is_allowed(configuredUrl) {
          allowedUrl := input.parameters.allowedNfsUrls[_]
          not endswith(allowedUrl, "*")
          configuredUrl == allowedUrl
        }

        is_allowed(configuredUrl) {
          allowedUrl := input.parameters.allowedNfsUrls[_]
          endswith(allowedUrl, "*")
          startswith(configuredUrl, trim_suffix(allowedUrl, "*"))
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: d1130417-383a-4994-a96f-1fe73c8c69f5
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: d1130417-383a-4994-a96f-1fe73c8c69f5
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts the use of names in RBAC subjects to permitted values.
      metadata.gatekeeper.sh/title: Restrict RBAC Subjects
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:12Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictrbacsubjects
    resourceVersion: "1746760543965183004"
    uid: c85731be-affe-44d4-a2f4-db3ddd13d307
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictRbacSubjects
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedSubjects:
                description: The list of names permitted in RBAC subjects.
                items:
                  properties:
                    name:
                      description: The exact-name or the pattern of the allowed subject
                      type: string
                    regexMatch:
                      description: The flag to allow a regular expression based match
                        on the name.
                      type: boolean
                  type: object
                type: array
            type: object
    targets:
    - rego: |
        package k8srestrictrbacsubjects

        violation[{"msg": msg}] {
          is_rolebinding_or_cluster_rolebinding(input.review.kind)
          subject := has_not_allowed_subject(input.review.object.subjects[_])
          msg := sprintf("%v <%v> contains restricted subject: %v", [input.review.kind.kind, input.review.object.metadata.name, subject])
        }

        is_rolebinding_or_cluster_rolebinding(kind) {
          kind.group == "rbac.authorization.k8s.io"
          kinds := {"RoleBinding", "ClusterRoleBinding"}
          kinds[kind.kind]
        }

        has_not_allowed_subject(subject) := subject {
          allowedSubjects := object.get(object.get(input, "parameters", {}), "allowedSubjects", {})
          not subject_is_allowed(subject, allowedSubjects)
        }

        subject_is_allowed(subject, allowedSubjects) {
          allowedSubject := allowedSubjects[_]
          has_exact_or_regex_match(allowedSubject, subject.name)
        }

        has_exact_or_regex_match(allowedSubject, subject_name) {
          not should_exactly_match(allowedSubject)
          regex.match(allowedSubject.name, subject_name)
        }

        has_exact_or_regex_match(allowedSubject, subject_name) {
          should_exactly_match(allowedSubject)
          allowedSubject.name == subject_name
        }

        should_exactly_match(allowedSubject) {
          not allowedSubject.regexMatch
        }

        should_exactly_match(allowedSubject) {
          allowedSubject.regexMatch == false
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: c85731be-affe-44d4-a2f4-db3ddd13d307
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: c85731be-affe-44d4-a2f4-db3ddd13d307
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts the subjects specified in ClusterRoleBindings and RoleBindings
        to a list of allowed subjects.
      metadata.gatekeeper.sh/title: Restrict Role Bindings
      metadata.gatekeeper.sh/version: 1.0.3
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:15Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictrolebindings
    resourceVersion: "1746760549365007010"
    uid: 7c3ad4e4-f255-47dc-8acc-7c08f8eb72c0
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictRoleBindings
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedSubjects:
                description: The list of subjects that are allowed to bind to the
                  restricted role.
                items:
                  properties:
                    apiGroup:
                      description: The Kubernetes API group of the subject.
                      type: string
                    kind:
                      description: The Kubernetes kind of the subject.
                      type: string
                    name:
                      description: The name of the subject which is matched exactly
                        as provided as well as based on a regular expression.
                      type: string
                    regexMatch:
                      description: The flag to allow a regular expression based match
                        on the name.
                      type: boolean
                  type: object
                type: array
              restrictedRole:
                description: The role that cannot be bound to unless expressly allowed.
                properties:
                  apiGroup:
                    description: The Kubernetes API group of the role.
                    type: string
                  kind:
                    description: The Kubernetes kind of the role.
                    type: string
                  name:
                    description: The name of the role.
                    type: string
                type: object
            type: object
    targets:
    - rego: |
        package k8srestrictrolebindings

        violation[{"msg": msg}] {
          is_rolebinding_or_cluster_rolebinding(input.review.kind)
          input.review.object.roleRef.apiGroup == input.parameters.restrictedRole.apiGroup
          input.review.object.roleRef.kind == input.parameters.restrictedRole.kind
          input.review.object.roleRef.name == input.parameters.restrictedRole.name
          has_not_allowed_subject(input.review.object.subjects, input.parameters)
          msg := sprintf("%v is restricted from referencing %v %v", [input.review.kind.kind, input.parameters.restrictedRole.kind, input.parameters.restrictedRole.name])
        }

        is_rolebinding_or_cluster_rolebinding(kind) {
          kind.group == "rbac.authorization.k8s.io"
          kinds := {"RoleBinding", "ClusterRoleBinding"}
          kinds[kind.kind]
        }

        has_not_allowed_subject(subjects, parameters) {
          subject := subjects[_]
          not subject_is_allowed(subject, parameters.allowedSubjects)
        }

        subject_is_allowed(subject, allowedSubjects) {
          allowedSubject := allowedSubjects[_]
          has_exact_or_regex_match(allowedSubject, subject.name)
          subject.kind == allowedSubject.kind
          api_group_is_equal(subject, allowedSubject)
        }

        has_exact_or_regex_match(allowedSubject, subject_name) {
          not should_exactly_match(allowedSubject)
          regex.match(allowedSubject.name, subject_name)
        }

        has_exact_or_regex_match(allowedSubject, subject_name) {
          should_exactly_match(allowedSubject)
          allowedSubject.name == subject_name
        }

        should_exactly_match(allowedSubject) {
          not allowedSubject.regexMatch
        }

        should_exactly_match(allowedSubject) {
          allowedSubject.regexMatch == false
        }

        # Check apiGroup value and return true if they are empty string or undefined
        api_group_is_equal(subject, allowedSubject) {
          has_empty_or_undefined_api_group(subject)
          has_empty_or_undefined_api_group(allowedSubject)
        }

        api_group_is_equal(subject, allowedSubject) {
          subject.apiGroup == allowedSubject.apiGroup
        }

        has_empty_or_undefined_api_group(subject) {
          not subject.apiGroup
        }

        has_empty_or_undefined_api_group(subject) {
          subject.apiGroup == ""
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 7c3ad4e4-f255-47dc-8acc-7c08f8eb72c0
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 7c3ad4e4-f255-47dc-8acc-7c08f8eb72c0
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Restricts rules that can be set on Role and ClusterRole objects.
      metadata.gatekeeper.sh/title: Restrict Role and ClusterRole rules.
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:11Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: k8srestrictrolerules
    resourceVersion: "1746760539912527020"
    uid: 4bc2a557-cfa0-4102-aa8e-4d5592110e02
  spec:
    crd:
      spec:
        names:
          kind: K8sRestrictRoleRules
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedRules:
                description: AllowedRules is the list of rules that are allowed on
                  Role or ClusterRole objects. If set, any item off this list will
                  be rejected.
                items:
                  properties:
                    apiGroups:
                      description: |
                        APIGroups is the name of the APIGroup that contains the resources. If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
                      items:
                        type: string
                      type: array
                    resources:
                      description: |
                        Resources is a list of resources this rule applies to. '*' represents all resources.
                      items:
                        type: string
                      type: array
                    verbs:
                      description: |
                        Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
                      items:
                        type: string
                      type: array
                  required:
                  - apiGroups
                  - resources
                  - verbs
                  type: object
                type: array
              disallowedRules:
                description: DisallowedRules is the list of rules that are NOT allowed
                  on Role or ClusterRole objects. If set, any item on this list will
                  be rejected.
                items:
                  properties:
                    apiGroups:
                      description: |
                        APIGroups is the name of the APIGroup that contains the resources. If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be disallowed. "" represents the core API group and "*" represents all API groups.
                      items:
                        type: string
                      type: array
                    resources:
                      description: |
                        Resources is a list of resources this rule applies to. '*' represents all resources.
                      items:
                        type: string
                      type: array
                    verbs:
                      description: |
                        Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
                      items:
                        type: string
                      type: array
                  required:
                  - apiGroups
                  - resources
                  - verbs
                  type: object
                type: array
              exemptions:
                description: Exemptions is the list of Roles and/or ClusterRoles names
                  that are allowed to violate this policy.
                properties:
                  clusterRoles:
                    items:
                      properties:
                        name:
                          description: Name is the name or a pattern of the ClusterRole
                            to be exempted.
                          type: string
                        regexMatch:
                          description: RegexMatch is the flag to toggle exact vs regex
                            match of the ClusterRole name.
                          type: boolean
                      required:
                      - name
                      type: object
                    type: array
                  roles:
                    items:
                      properties:
                        name:
                          description: Name is the name of the Role to be exempted.
                          type: string
                        namespace:
                          description: Namespace is the namespace of the Role to be
                            exempted.
                          type: string
                      required:
                      - name
                      - namespace
                      type: object
                    type: array
                type: object
            type: object
    targets:
    - rego: |
        package k8srestrictrolerules

        import future.keywords.in

        # allowed rules validation
        violation[{"msg": msg}] {
          count(input.parameters.allowedRules) > 0
          is_role_or_clusterrole(input.review.object)
          count(input.review.object.rules) > 0
          not is_exemped(input.review.object)

          satisfied := [disallowed |
            rule := input.review.object.rules[_]
            not allowed_rules_match(rule)
            disallowed := rule
          ]

          count(satisfied) > 0

          msg := sprintf("%v <%v> has a rule of <%v> that's not on allowedRules list", [input.review.object.kind, fmt_name(input.review.object), satisfied[_]])
        }

        allowed_rules_match(rule) {
          satisfied := [good |
            item := input.parameters.allowedRules[_]
            superset_contains_all(rule.apiGroups, item.apiGroups)
            superset_contains_all(rule.resources, item.resources)
            superset_contains_all(rule.verbs, item.verbs)
            good := item
          ]

          count(satisfied) > 0
        }

        # disallowed rules validation
        violation[{"msg": msg}] {
          count(input.parameters.disallowedRules) > 0
          is_role_or_clusterrole(input.review.object)
          count(input.review.object.rules) > 0
          not is_exemped(input.review.object)

          satisfied := [disallowed |
            rule := input.review.object.rules[_]
            disallowed_rules_match(rule)
            disallowed := rule
          ]

          count(satisfied) > 0

          msg := sprintf("%v <%v> has a rule of <%v> that's on disallowedRules list", [input.review.object.kind, fmt_name(input.review.object), satisfied[_]])
        }

        disallowed_rules_match(rule) {
          satisfied := [good |
            item := input.parameters.disallowedRules[_]
            superset_contains_any(rule.apiGroups, item.apiGroups)
            superset_contains_any(rule.resources, item.resources)
            superset_contains_any(rule.verbs, item.verbs)
            good := item
          ]

          count(satisfied) > 0
        }

        is_role_or_clusterrole(obj) {
          obj.apiVersion == "rbac.authorization.k8s.io/v1"
          obj.kind == "Role"
        }

        is_role_or_clusterrole(obj) {
          obj.apiVersion == "rbac.authorization.k8s.io/v1"
          obj.kind == "ClusterRole"
        }

        fmt_name(obj) := output {
          obj.kind == "ClusterRole"
          output := obj.metadata.name
        }

        fmt_name(obj) := output {
          obj.kind == "Role"
          output := sprintf("%v/%v", [obj.metadata.namespace, obj.metadata.name])
        }

        superset_contains_all(_, superset) {
          "*" in superset
        }

        superset_contains_all(subset, superset) {
          some i, j
          found := [f | superset[i] == subset[j]; f := subset[j]]
          count(found) == count(subset)
        }

        superset_contains_any(_, superset) {
          "*" in superset
        }

        superset_contains_any(subset, _) {
          "*" in subset
        }

        superset_contains_any(subset, superset) {
          some i, j
          found := [f | superset[i] == subset[j]; f := subset[j]]
          count(found) > 0
        }

        # check for cluster role exemption
        is_exemped(obj) {
          obj.kind == "ClusterRole"
          count(input.parameters.exemptions.clusterRoles) > 0
          exemption := input.parameters.exemptions.clusterRoles[_]
          has_exact_or_regex_match(exemption, obj.metadata)
        }

        # check for role exemption
        is_exemped(obj) {
          obj.kind == "Role"
          count(input.parameters.exemptions.roles) > 0
          exemption := input.parameters.exemptions.roles[_]
          exemption.name == obj.metadata.name
          exemption.namespace = obj.metadata.namespace
        }

        has_exact_or_regex_match(exemption, metadata) {
          exemption.regexMatch == true
          regex.match(exemption.name, metadata.name)
        }

        has_exact_or_regex_match(exemption, metadata) {
          not exemption.regexMatch == true
          exemption.name == metadata.name
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 4bc2a557-cfa0-4102-aa8e-4d5592110e02
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 4bc2a557-cfa0-4102-aa8e-4d5592110e02
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Requires storage classes to be specified when used. Only Gatekeeper
        3.9+ and non-ephemeral containers are supported.
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups":["storage.k8s.io"],
              "versions": ["v1"],
              "kinds": ["StorageClass"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Storage Class
      metadata.gatekeeper.sh/version: 1.1.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:21Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8sstorageclass
    resourceVersion: "1746760552648159005"
    uid: 86587afe-0c38-4f45-8994-2fc6f59dd12b
  spec:
    crd:
      spec:
        names:
          kind: K8sStorageClass
        validation:
          legacySchema: false
          openAPIV3Schema:
            description: Requires storage classes to be specified when used.
            properties:
              allowedStorageClasses:
                description: An optional allow-list of storage classes.  If specified,
                  any storage class not in the `allowedStorageClasses` parameter is
                  disallowed.
                items:
                  type: string
                type: array
              includeStorageClassesInMessage:
                default: true
                type: boolean
            type: object
    targets:
    - rego: |
        package k8sstorageclass

        is_pvc(obj) {
          obj.apiVersion == "v1"
          obj.kind == "PersistentVolumeClaim"
        }

        is_statefulset(obj) {
          obj.apiVersion == "apps/v1"
          obj.kind == "StatefulSet"
        }

        violation[{"msg": msg}] {
          not data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"]
          msg := sprintf("StorageClasses not synced. Gatekeeper may be misconfigured. Please have a cluster-admin consult the documentation.", [])
        }

        storageclass_allowed(name) {
          data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][name]
          # support both direct use of * and as the default value
          object.get(input.parameters, "allowedStorageClasses", ["*"])[_] == "*"
        }

        storageclass_allowed(name) {
          data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][name]
          input.parameters.allowedStorageClasses[_] == name
        }

        violation[{"msg": pvc_storageclass_badname_msg}] {
          is_pvc(input.review.object)
          not storageclass_allowed(input.review.object.spec.storageClassName)
        }
        pvc_storageclass_badname_msg := sprintf("pvc did not specify a valid storage class name <%v>. Must be one of [%v]", args) {
          input.parameters.includeStorageClassesInMessage
          object.get(input.parameters, "allowedStorageClasses", null) == null
          args := [
            input.review.object.spec.storageClassName,
            concat(", ", [n | data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][n]])
          ]
        } else := sprintf("pvc did not specify an allowed and valid storage class name <%v>. Must be one of [%v]", args) {
          input.parameters.includeStorageClassesInMessage
          object.get(input.parameters, "allowedStorageClasses", null) != null
          sc := {n | data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][n]} & {x | x = object.get(input.parameters, "allowedStorageClasses", [])[_]}
          args := [
            input.review.object.spec.storageClassName,
            concat(", ", sc)
          ]
        } else := sprintf(
          "pvc did not specify a valid storage class name <%v>.",
          [input.review.object.spec.storageClassName]
        )

        violation[{"msg": pvc_storageclass_noname_msg}] {
          is_pvc(input.review.object)
          not input.review.object.spec.storageClassName
        }
        pvc_storageclass_noname_msg := sprintf("pvc did not specify a storage class name. Must be one of [%v]", args) {
          input.parameters.includeStorageClassesInMessage
          args := [
            concat(", ", [n | data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][n]])
          ]
        } else := sprintf(
          "pvc did not specify a storage class name.",
          []
        )

        violation[{"msg": statefulset_vct_badname_msg(vct)}] {
          is_statefulset(input.review.object)
          vct := input.review.object.spec.volumeClaimTemplates[_]
          not storageclass_allowed(vct.spec.storageClassName)
        }
        statefulset_vct_badname_msg(vct) := msg {
          input.parameters.includeStorageClassesInMessage
          object.get(input.parameters, "allowedStorageClasses", null) == null
          msg := sprintf(
              "statefulset did not specify a valid storage class name <%v>. Must be one of [%v]", [
              vct.spec.storageClassName,
              concat(", ", [n | data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][n]])
          ])
        }
        statefulset_vct_badname_msg(vct) := msg {
          input.parameters.includeStorageClassesInMessage
          object.get(input.parameters, "allowedStorageClasses", null) != null
          sc := {n | data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][n]} & {x | x = object.get(input.parameters, "allowedStorageClasses", [])[_]}
          msg := sprintf(
              "statefulset did not specify an allowed and valid storage class name <%v>. Must be one of [%v]", [
              vct.spec.storageClassName,
              concat(", ", sc)
          ])
        }
        statefulset_vct_badname_msg(vct) := msg {
          not input.parameters.includeStorageClassesInMessage
          msg := sprintf(
            "statefulset did not specify a valid storage class name <%v>.", [
              vct.spec.storageClassName
          ])
        }

        violation[{"msg": statefulset_vct_noname_msg}] {
          is_statefulset(input.review.object)
          vct := input.review.object.spec.volumeClaimTemplates[_]
          not vct.spec.storageClassName
        }
        statefulset_vct_noname_msg := sprintf("statefulset did not specify a storage class name. Must be one of [%v]", args) {
          input.parameters.includeStorageClassesInMessage
          args := [
            concat(", ", [n | data.inventory.cluster["storage.k8s.io/v1"]["StorageClass"][n]])
          ]
        } else := sprintf(
          "statefulset did not specify a storage class name.",
          []
        )
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 86587afe-0c38-4f45-8994-2fc6f59dd12b
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 86587afe-0c38-4f45-8994-2fc6f59dd12b
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires all Ingress rule hosts to be unique.
        Does not handle hostname wildcards: https://kubernetes.io/docs/concepts/services-networking/ingress/
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups": ["extensions"],
              "versions": ["v1beta1"],
              "kinds": ["Ingress"]
            },
            {
              "groups": ["networking.k8s.io"],
              "versions": ["v1beta1", "v1"],
              "kinds": ["Ingress"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Unique Ingress Host
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:10Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8suniqueingresshost
    resourceVersion: "1746760528057295002"
    uid: 4aa621db-7565-4eec-8d5c-8fa42f7a6dd2
  spec:
    crd:
      spec:
        names:
          kind: K8sUniqueIngressHost
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8suniqueingresshost

        identical(obj, review) {
          obj.metadata.namespace == review.object.metadata.namespace
          obj.metadata.name == review.object.metadata.name
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Ingress"
          regex.match("^(extensions|networking.k8s.io)$", input.review.kind.group)
          host := input.review.object.spec.rules[_].host
          other := data.inventory.namespace[_][otherapiversion]["Ingress"][name]
          regex.match("^(extensions|networking.k8s.io)/.+$", otherapiversion)
          other.spec.rules[_].host == host
          not identical(other, input.review)
          msg := sprintf("ingress host conflicts with an existing ingress <%v>", [host])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 4aa621db-7565-4eec-8d5c-8fa42f7a6dd2
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 4aa621db-7565-4eec-8d5c-8fa42f7a6dd2
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires Services to have unique selectors within a namespace. Selectors are considered the same if they have identical keys and values. Selectors may share a key/value pair so long as there is at least one distinct key/value pair between them.
        https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
      metadata.gatekeeper.sh/requires-sync-data: |
        "[
          [
            {
              "groups":[""],
              "versions": ["v1"],
              "kinds": ["Service"]
            }
          ]
        ]"
      metadata.gatekeeper.sh/title: Unique Service Selector
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:20Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
      policycontroller.configmanagement.gke.io/referential: "true"
    name: k8suniqueserviceselector
    resourceVersion: "1746760552385359009"
    uid: a124cba7-9ad2-4065-9ac9-9f7b7b988205
  spec:
    crd:
      spec:
        names:
          kind: K8sUniqueServiceSelector
        validation:
          legacySchema: false
    targets:
    - rego: |
        package k8suniqueserviceselector

        make_apiversion(kind) = apiVersion {
          g := kind.group
          v := kind.version
          g != ""
          apiVersion = sprintf("%v/%v", [g, v])
        }

        make_apiversion(kind) = apiVersion {
          kind.group == ""
          apiVersion = kind.version
        }

        identical(obj, review) {
          obj.metadata.namespace == review.namespace
          obj.metadata.name == review.name
          obj.kind == review.kind.kind
          obj.apiVersion == make_apiversion(review.kind)
        }

        flatten_selector(obj) = flattened {
          selectors := [s | s = concat(":", [key, val]); val = obj.spec.selector[key]]
          flattened := concat(",", sort(selectors))
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Service"
          input.review.kind.version == "v1"
          input.review.kind.group == ""
          input_selector := flatten_selector(input.review.object)
          other := data.inventory.namespace[namespace][_]["Service"][name]
          not identical(other, input.review)
          other_selector := flatten_selector(other)
          input_selector == other_selector
          msg := sprintf("same selector as service <%v> in namespace <%v>", [name, namespace])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: a124cba7-9ad2-4065-9ac9-9f7b7b988205
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: a124cba7-9ad2-4065-9ac9-9f7b7b988205
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Blocks updating the service account on resources that abstract
        over Pods. This policy is ignored in audit mode.
      metadata.gatekeeper.sh/title: Block updating Service Account
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:17Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: noupdateserviceaccount
    resourceVersion: "1746760551188703021"
    uid: 8c0e68ec-c9b3-4df1-896b-1b6238f4d0ed
  spec:
    crd:
      spec:
        names:
          kind: NoUpdateServiceAccount
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedGroups:
                description: Groups that should be allowed to bypass the policy.
                items:
                  type: string
                type: array
              allowedUsers:
                description: Users that should be allowed to bypass the policy.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package noupdateserviceaccount

        privileged(userInfo, allowedUsers, _) {
          # Allow if the user is in allowedUsers.
          # Use object.get so omitted parameters can't cause policy bypass by
          # evaluating to undefined.
          username := object.get(userInfo, "username", "")
          allowedUsers[_] == username
        }

        privileged(userInfo, _, allowedGroups) {
          # Allow if the user's groups intersect allowedGroups.
          # Use object.get so omitted parameters can't cause policy bypass by
          # evaluating to undefined.
          userGroups := object.get(userInfo, "groups", [])
          groups := {g | g := userGroups[_]}
          allowed := {g | g := allowedGroups[_]}
          intersection := groups & allowed
          count(intersection) > 0
        }

        get_service_account(obj) = spec {
          obj.kind == "Pod"
          spec := obj.spec.serviceAccountName
        } {
          obj.kind == "ReplicationController"
          spec := obj.spec.template.spec.serviceAccountName
        } {
          obj.kind == "ReplicaSet"
          spec := obj.spec.template.spec.serviceAccountName
        } {
          obj.kind == "Deployment"
          spec := obj.spec.template.spec.serviceAccountName
        } {
          obj.kind == "StatefulSet"
          spec := obj.spec.template.spec.serviceAccountName
        } {
          obj.kind == "DaemonSet"
          spec := obj.spec.template.spec.serviceAccountName
        } {
          obj.kind == "Job"
          spec := obj.spec.template.spec.serviceAccountName
        } {
          obj.kind == "CronJob"
          spec := obj.spec.jobTemplate.spec.template.spec.serviceAccountName
        }

        violation[{"msg": msg}] {
          # This policy only applies to updates of existing resources.
          input.review.operation == "UPDATE"

          # Use object.get so omitted parameters can't cause policy bypass by
          # evaluating to undefined.
          params := object.get(input, "parameters", {})
          allowedUsers := object.get(params, "allowedUsers", [])
          allowedGroups := object.get(params, "allowedGroups", [])

          # Extract the service account.
          oldKSA := get_service_account(input.review.oldObject)
          newKSA := get_service_account(input.review.object)

          # Deny unprivileged users and groups from changing serviceAccountName.
          not privileged(input.review.userInfo, allowedUsers, allowedGroups)
          oldKSA != newKSA
          msg := "user does not have permission to modify serviceAccountName"
        } {
          # Defensively require object to have a serviceAccountName.
          input.review.operation == "UPDATE"
          not get_service_account(input.review.object)
          msg := "missing serviceAccountName field in object under review"
        } {
          # Defensively require oldObject to have a serviceAccountName.
          input.review.operation == "UPDATE"
          not get_service_account(input.review.oldObject)
          msg := "missing serviceAccountName field in oldObject under review"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 8c0e68ec-c9b3-4df1-896b-1b6238f4d0ed
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 8c0e68ec-c9b3-4df1-896b-1b6238f4d0ed
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: 'Requires that `STRICT` Istio mutual TLS is always specified when
        using [PeerAuthentication](https://istio.io/latest/docs/reference/config/security/peer_authentication/).
        This constraint also ensures that the deprecated [Policy](https://istio.io/v1.4/docs/reference/config/security/istio.authentication.v1alpha1/#Policy)
        and MeshPolicy resources enforce `STRICT` mutual TLS. See: https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/#lock-down-mutual-tls-for-the-entire-mesh'
      metadata.gatekeeper.sh/title: Require STRICT Istio mTLS Policy
      metadata.gatekeeper.sh/version: 1.0.4
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:20Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: policystrictonly
    resourceVersion: "1746760552117151003"
    uid: bae96cb4-38ba-4cf5-8688-509a80a6c136
  spec:
    crd:
      spec:
        names:
          kind: PolicyStrictOnly
        validation:
          legacySchema: false
    targets:
    - rego: |
        package asm.guardrails.policystrictonly

        import future.keywords.in

        OLD_KINDS := ["Policy", "MeshPolicy"]

        strict_mtls {
          p := input.review.object
          count(p.spec.peers) == 1
          p.spec.peers[0].mtls.mode == "STRICT"
        }

        # VIOLATION peer authentication does not set mTLS correctly
        violation[{"msg": msg}] {
          p := input.review.object
          startswith(p.apiVersion, "authentication.istio.io/")
          p.kind in OLD_KINDS
          not strict_mtls
          msg := "spec.peers does not include STRICT mTLS settings"
        }

        # VIOLATION spec.mtls must be set to `STRICT`
        violation[{"msg": msg}] {
          p := input.review.object

          startswith(p.apiVersion, "security.istio.io/")
          p.kind == "PeerAuthentication"

          not p.spec.mtls.mode == "STRICT"
          msg := "spec.mtls.mode must be set to `STRICT`"
        }

        # VIOLATION no ports can override `STRICT` mTLS mode
        violation[{"msg": msg}] {
          some port
          p := input.review.object

          startswith(p.apiVersion, "security.istio.io/")
          p.kind == "PeerAuthentication"

          valid_modes := {"UNSET", "STRICT"}
          count({p.spec.portLevelMtls[port].mode} - valid_modes) > 0
          msg := sprintf("port <%v> has invalid mtls mode <%v>", [port, p.spec.portLevelMtls[port].mode])
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: bae96cb4-38ba-4cf5-8688-509a80a6c136
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: bae96cb4-38ba-4cf5-8688-509a80a6c136
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Controls which inbound ports, outbound ports, and outbound IP ranges can be
        excluded from Istio network capture. Ports and IP ranges that bypass Istio
        network capture are not handled by the Istio proxy and are not subject to
        Istio mTLS authentication, authorization policy, and other Istio features.
        This constraint can be used to apply restrictions to the use of the
        following annotations:

        * `traffic.sidecar.istio.io/excludeInboundPorts`
        * `traffic.sidecar.istio.io/excludeOutboundPorts`
        * `traffic.sidecar.istio.io/excludeOutboundIPRanges`

        See https://istio.io/latest/docs/reference/config/annotations/.

        When restricting outbound IP ranges, the constraint calculates whether excluded
        IP ranges match or are a subset of the allowed IP range exclusions.

        When using this constraint all inbound ports, outbound ports and outbound IP
        ranges must always be included by either setting the corresponding "include"
        annotations to `"*"` or leaving them unset. Setting any of the following
        annotations to anything other than `"*"` is not allowed:

        * `traffic.sidecar.istio.io/includeInboundPorts`
        * `traffic.sidecar.istio.io/includeOutboundPorts`
        * `traffic.sidecar.istio.io/includeOutboundIPRanges`

        This constraint always allows port 15020 to be excluded because the Istio sidecar
        injector always adds it to the `traffic.sidecar.istio.io/excludeInboundPorts`
        annotation so that it can be used for health checking.
      metadata.gatekeeper.sh/title: Restrict Network Exclusions
      metadata.gatekeeper.sh/version: 1.0.2
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:10Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: restrictnetworkexclusions
    resourceVersion: "1746760526298383022"
    uid: 0fed1a36-bf33-4686-964b-0e9f48f5abae
  spec:
    crd:
      spec:
        names:
          kind: RestrictNetworkExclusions
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              allowedInboundPortExclusions:
                description: A list of ports that this constraint will allow in the
                  `traffic.sidecar.istio.io/excludeInboundPorts` annotation.
                items:
                  type: string
                type: array
              allowedOutboundIPRangeExclusions:
                description: A list of IP ranges that this constraint will allow in
                  the `traffic.sidecar.istio.io/excludeOutboundIPRanges` annotation.
                  The constraint calculates whether excluded IP ranges match or are
                  a subset of the ranges in this list.
                items:
                  type: string
                type: array
              allowedOutboundPortExclusions:
                description: A list of ports that this constraint will allow in the
                  `traffic.sidecar.istio.io/excludeOutboundPorts` annotation.
                items:
                  type: string
                type: array
            type: object
    targets:
    - rego: |
        package asm.guardrails.networkexclusions

        import future.keywords.in

        resource := input.review.object

        annotations := resource.metadata.annotations

        kind := input.review.kind.kind

        ################
        # Inbound ports
        ################

        # The includeInboundPorts annotation can be used to include specific ports - all
        # other ports are then excluded - this constaint will be violated if used in
        # this way.

        all_inbound_ports_included {
          not annotations["traffic.sidecar.istio.io/includeInboundPorts"]
        }

        all_inbound_ports_included {
          "*" in split_str_set(annotations["traffic.sidecar.istio.io/includeInboundPorts"])
        }

        violation[{"msg": msg}] {
          not all_inbound_ports_included
          msg := sprintf("%v includes specific inbound ports. If setting 'traffic.sidecar.istio.io/includeInboundPorts' it may only be set to '*'. Use 'traffic.sidecar.istio.io/excludeInboundPorts' to set specific port exclusions", [resource.kind])
        }

        # 15020 is always allowed for health checks
        violation[{"msg": msg, "details": {"deniedInboundPorts": forbiddenInboundPortExclusions}}] {
          a := annotations["traffic.sidecar.istio.io/excludeInboundPorts"]
          inboundPortExclusions = split_str_set(a)

          # The sidecar injector always excludes 15020 for health checks
          allowedInboundPortExclusions := {port | port := input.parameters.allowedInboundPortExclusions[_]} | {"15020"}
          forbiddenInboundPortExclusions := inboundPortExclusions - allowedInboundPortExclusions
          count(forbiddenInboundPortExclusions) > 0

          msg := sprintf("%v has forbidden inbound port exclusions: %v", [kind, forbiddenInboundPortExclusions])
        }

        #################
        # Outbound ports
        #################

        # The includeOutboundPorts annotation can be used to include specific ports -
        # this constraint will be violated if used in this way. Note that the behaviour
        # of outbound port inclusion is different from inbound but the constraint
        # behaviour is the same for consistency and to be future proof.

        all_outbound_ports_included {
          not annotations["traffic.sidecar.istio.io/includeOutboundPorts"]
        }

        all_outbound_ports_included {
          "*" in split_str_set(annotations["traffic.sidecar.istio.io/includeOutboundPorts"])
        }

        violation[{"msg": msg}] {
          not all_outbound_ports_included
          msg := sprintf("%v includes specific outbound ports. If setting 'traffic.sidecar.istio.io/includeOutboundPorts' it may only be set to '*'. Use 'traffic.sidecar.istio.io/excludeOutboundPorts' to set specific port exclusions", [kind])
        }

        violation[{"msg": msg, "details": {"deniedOutboundPorts": forbiddenOutboundPortExclusions}}] {
          a := annotations["traffic.sidecar.istio.io/excludeOutboundPorts"]
          outboundPortExclusions = split_str_set(a)
          allowedOutboundPortExclusions := {port | port := input.parameters.allowedOutboundPortExclusions[_]}
          forbiddenOutboundPortExclusions := outboundPortExclusions - allowedOutboundPortExclusions
          count(forbiddenOutboundPortExclusions) > 0

          msg := sprintf("%v has forbidden outbound port exclusions: %v", [kind, forbiddenOutboundPortExclusions])
        }

        #####################
        # Outbound IP ranges
        #####################

        # The includeOutboundIPRanges annotation can be used to include specific IP
        # ranges - all other IP ranges are then excluded - this constraint will be
        # violated if used in this way.

        all_outbound_ip_ranges_included {
          not annotations["traffic.sidecar.istio.io/includeOutboundIPRanges"]
        }

        all_outbound_ip_ranges_included {
          "*" in split_str_set(annotations["traffic.sidecar.istio.io/includeOutboundIPRanges"])
        }

        violation[{"msg": msg}] {
          not all_outbound_ip_ranges_included
          msg := sprintf("%v includes specific outbound IP ranges. If setting 'traffic.sidecar.istio.io/includeOutboundIPRanges' it may only be set to '*'. Use 'traffic.sidecar.istio.io/excludeOutboundIPRanges' to set specific IP range exclusions", [kind])
        }

        violation[{"msg": msg, "details": {"deniedOutboundIPRanges": forbiddenOutboundIPRangeExclusions}}] {
          a := annotations["traffic.sidecar.istio.io/excludeOutboundIPRanges"]
          outboundIPRangeExclusions = split_str_set(a)
          allowedOutboundIPRangeExclusions := {cidr | cidr := input.parameters.allowedOutboundIPRangeExclusions[_]}
          matches := net.cidr_contains_matches(allowedOutboundIPRangeExclusions, outboundIPRangeExclusions)
          permittedMatches := {match | match := matches[_][1]}
          forbiddenOutboundIPRangeExclusions = outboundIPRangeExclusions - permittedMatches
          count(forbiddenOutboundIPRangeExclusions) > 0

          msg := sprintf("%v has forbidden outbound IP range exclusions: %v", [kind, forbiddenOutboundIPRangeExclusions])
        }

        split_str_set(str) := {x |
          some i
          p := split(str, ",")
          x := p[i]
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: 0fed1a36-bf33-4686-964b-0e9f48f5abae
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: 0fed1a36-bf33-4686-964b-0e9f48f5abae
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: |-
        Requires that Istio AuthorizationPolicy rules have source principals set to something other than "*".
        https://istio.io/latest/docs/reference/config/security/authorization-policy/
      metadata.gatekeeper.sh/title: Require Istio AuthorizationPolicy Source not all
      metadata.gatekeeper.sh/version: 1.0.1
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:13Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: sourcenotallauthz
    resourceVersion: "1746760546733551011"
    uid: f0e987bd-5cc3-4d30-9df3-a472fc622820
  spec:
    crd:
      spec:
        names:
          kind: SourceNotAllAuthz
        validation:
          legacySchema: false
    targets:
    - rego: |
        package asm.guardrails.sourcenotallauthz

        # spec.rules[].from[].source.principal does not exist
        violation[{"msg": msg}] {
          p := input.review.object

          startswith(p.apiVersion, "security.istio.io/")
          p.kind == "AuthorizationPolicy"

          rule := p.spec.rules[_]

          sources := {i | rule.from[_].source[i]}

          not sources.principals

          msg := "source.principals does not exist"
        }

        # spec.rules[].from[].source.principal is set to '*'
        violation[{"msg": msg}] {
          p := input.review.object

          startswith(p.apiVersion, "security.istio.io/")
          p.kind == "AuthorizationPolicy"

          rule := p.spec.rules[_]

          principals := {v | v := rule.from[_].source.principals[_]}

          principals["*"]

          msg := "source.principals[] cannot be '*'"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: f0e987bd-5cc3-4d30-9df3-a472fc622820
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: f0e987bd-5cc3-4d30-9df3-a472fc622820
    created: true
- apiVersion: templates.gatekeeper.sh/v1
  kind: ConstraintTemplate
  metadata:
    annotations:
      description: Verifies deprecated Kubernetes APIs to ensure all the API versions
        are up to date. This template does not apply to audit as audit looks at the
        resources which are already present in the cluster with non-deprecated API
        versions.
      metadata.gatekeeper.sh/title: Verify deprecated APIs
      metadata.gatekeeper.sh/version: 1.0.0
      policycontroller.configmanagement.gke.io/version: 1.20.2
    creationTimestamp: "2025-05-09T03:15:18Z"
    generation: 1
    labels:
      app.kubernetes.io/managed-by: anthospolicycontroller.googleapis.com
    name: verifydeprecatedapi
    resourceVersion: "1746760551685263013"
    uid: ede94b8e-9a20-4209-835f-954be576a649
  spec:
    crd:
      spec:
        names:
          kind: VerifyDeprecatedAPI
        validation:
          legacySchema: false
          openAPIV3Schema:
            properties:
              k8sVersion:
                description: kubernetes version
                type: number
              kvs:
                description: Deprecated api versions and corresponding kinds
                items:
                  properties:
                    deprecatedAPI:
                      description: deprecated api
                      example: flowcontrol.apiserver.k8s.io/v1beta2
                      type: string
                    kinds:
                      description: impacted list of kinds
                      example: '["FlowSchema", "PriorityLevelConfiguration"]'
                      items:
                        type: string
                      type: array
                    targetAPI:
                      description: target api
                      example: flowcontrol.apiserver.k8s.io/v1beta3
                      type: string
                  type: object
                type: array
            type: object
    targets:
    - rego: |
        package verifydeprecatedapi

        violation[{"msg": msg}] {
          kvs := input.parameters.kvs[_]
          kvs.deprecatedAPI == input.review.object.apiVersion
          k := kvs.kinds[_]
          k == input.review.object.kind
          msg := get_message(input.review.object.kind, input.review.object.apiVersion, input.parameters.k8sVersion, kvs.targetAPI)
        }

        get_message(kind, apiVersion, k8sVersion, targetAPI) = msg {
          not match(targetAPI)
          msg := sprintf("API %v for %v is deprecated in Kubernetes version %v, please use %v instead", [kind, apiVersion, k8sVersion, targetAPI])
        }

        get_message(kind, apiVersion, k8sVersion, targetAPI) = msg {
          match(targetAPI)
          msg := sprintf("API %v for %v is deprecated in Kubernetes version %v, please see Kubernetes API deprecation guide", [kind, apiVersion, k8sVersion])
        }

        match(api) {
          api == "None"
        }
      target: admission.k8s.gatekeeper.sh
  status:
    byPod:
    - id: gatekeeper-audit-7dc4885d56-lxwt8
      observedGeneration: 1
      operations:
      - audit
      - status
      templateUID: ede94b8e-9a20-4209-835f-954be576a649
    - id: gatekeeper-controller-manager-5c98d495b6-kjwdf
      observedGeneration: 1
      operations:
      - webhook
      templateUID: ede94b8e-9a20-4209-835f-954be576a649
    created: true
kind: List
metadata:
  resourceVersion: ""
